\documentclass[12pt]{book}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\begin{document}


\chapter{Прочисть свой код}

Чтобы использовать JSX без проблем, необходимо понимать как он работает под капотом и почему его удобно использовать для создания интерфейса.

Наша цель - писать чистый и поддерживаемый JSX код, и для этого мы должны знать, как JSX транслируется в JavaScript код и какие предоставляет фичи.

В этом блоке мы разберем:

\begin{itemize}
  \item Что такое JSX и почему мы должны его использовать
  \item Что такое Babel и как он используется в современной разработке
  \item Основные фичи JSX и его отличие от HTML
  \item Лучшие практики при написании кода на JSX
  \item Статическую проверку кода с ESLint 
  \item Основы функционального программирования и его применение в создании React компонент
\end{itemize}


\section{JSX}

**Example of JSX

React предлагает два основных способа описания элементов: использование библиотечных JavaScript функций и использование JSX разметки, похожей на XML. 

На первый взгляд может показаться, что JSX - это странная смесь из HTML и JavaScript. Но на деле, JSX разметка перед попаданием в браузер конвертируется в чистый JavaScript. Этот прием позволяет достаточно лаконично и визуально понятно описывать компоненты.

\subsection*{Babel}

Чтобы использовать JSX(а также фичи ES2015) нам необходимо установить Babel. 

Важно понимать, почему мы добавляем Babel в наш процесс разработки. Основная причина в желании использовать фичи языка, которые еще не доступны в браузере. Новые фичи языка часто помогают нам писать код чище и понятнее, но браузер не может их исполнить.

Решение - писать код с JSX и ES2015, а затем транслировать в ES5, который сейчас могут запускать большинство браузеров, используя Babel.

Чтобы использовать Babel, его необходимо установить:

npm install --global babel-cli

Чтобы не загромождать npm пакетами систему, можно установить babel в конкретный проект и использовать через npm скрипты. Но для учебных целей установим его глобально.

После установки мы можем транслировать любой JavaScript файл:

babel source.js -o output.js

Одна из сильных сторон Babel - возможность его гибкой конфигурации. Babel всего лишь транслирует один файл в другой, а чтобы были произведены изменения содержимого, нужно сконфигурировать этот процесс.

Для Babel уже создано множество пресетов, в том числе и для JSX и ES2015. Чтобы установить их, необходимо выполнить:

npm install --global babel-preset-es2015 babel-preset-react ,

а также добавить в домашнюю директорию (или в папку с проектом) файл .babelrc с содержимым:

\{
     "presets": [
"es2015",
"react" ]
\}

С этого момента мы можем спокойно использовать все фичи ES2015 и JSX, а потом запускать в браузере транслированный Babel'ем код.

\subsection*{Hello, World}

Посмотрим на простейший пример создание элемента в React. 

Мы можем создать \textit{div} элемент с помощью метода \textit{createElement} библиотеки React:

React.createElement('div')

Также мы можем создать его, используя JSX:

<div />

В данном примере JSX код выглядит как HTML. Но нужно понимать одну важную вещь, оба варианта, написанные выше, эквивалентны. 

На самом деле, если мы транслируем <div /> в JavaScript при помощи babel, то мы получим React.createElement('div'). Это необходимо всегда держать в голове при описании интерфейса на React.

\subsection*{DOM элементы и React компоненты}

C JSX мы можем создавать и HTML элементы и React элементы. Разница лишь в том, пишем мы название элемента с заглавной буквы или нет.

Например, в JSX мы можем создать <button /> и <Button /> элементы.

В первом случае результатом трансляции будет:

React.createElement('button')

Во втором случае:

React.createElement(Button)

Разница в том, что в первом случае тип DOM элемента передается как строка, а во втором случае мы передаем название переменной, которая должна быть как минимум определена в области видимости данного кода.

\subsection*{Props}

JSX очень удобен, если у DOM или React компонентов есть параметры. В XML в целом гораздо нагляднее передавать параметры элементам:

<img src="https://facebook.github.io/react/img/logo.svg"
   alt="React.js" />

Аналогичный код на JavaScript:

%React.createElement("img", {
%     src: "https://facebook.github.io/react/img/logo.svg",
%     alt: "React.js"
%});

Читаемость резко падает даже с небольшим количеством параметров.

\subsection*{Children}

JSX позволяет определять дочерние элементы, чтобы создавать комплексные древовидные разметки.

Простой пример дочернего элемента - текст внутри тега:

<a href="https://facebook.github.io/react/">Click me!</a>

Этот пример будет транслирован в:

%React.createElement(
%     "a",
%     { href: "https://facebook.github.io/react/" },
%     "Click me!"
%   );
   
Если этот тег будет обернут в другой, например div, то JSX будет выглядеть как:

 <div>
     <a href="https://facebook.github.io/react/">Click me!</a>
</div>

JavaScript эквивалентный этому JSX:

%React.createElement(
%     "div",
%     null,
%     React.createElement(
%       "a",
%       { href: "https://facebook.github.io/react/" },
%       "Click me!"
%) );

Достаточно очевидно, что чем сложнее разметка, тем больше JSX улучшает читаемость кода. Однако не следует забывать, что каждому JSX коду соответствует однозначно определенный код на JavaScript.

Так как JSX всего лишь удобный синтаксис для JavaScript, вполне логично, что в нем можно использовать JavaScript выражения. 

Для того, чтобы сделать это, выражение должно быть обернуто в фигурные скобки:

<div>
     Hello, {variable}.
     I'm a {function()}.
</div>

Или например в параметрах элемента:

<a href={this.makeHref()}>Click me!</a>


\subsection*{Differences with HTML}

Мы посмотрели, чем похожи JSX и HTML. Теперь посмотрим в чем они отличаются и в чем причины этих различий.

\subsubsection*{Аттрибуты}

Мы должны помнить, что JSX не стандарт языка, и транслируется в JavaScript. Из-за этого некоторые атрибуты не доступны для использования.

Например, вместо атрибута class мы вынуждены использовать className, а вместо for использовать htmlFor:

<label className="awesome-label" htmlFor="name" />

Причина этого в том, что слова class и for зарезервированы в языке JavaScript.

\subsubsection*{Стили}

Стили - пример значительных различий между HTML и JSX. Подробнее мы посмотрим на них в одной из следующих глав. 

Сейчас отметим, что через JSX в атрибуте style не поддерживается CSS строка. Вместо нее React ожидает JavaScript объект, в котором имена стилей переданы в camelCase:

<div style={{ backgroundColor: 'red' }} />

\subsubsection*{Root}

Стоит отметить важное отличие JSX от HTML, которое заключается в том, что нельзя создать несколько элементов на одном уровне без оборачивания другим элементом:

<div />
<div />

Этот пример вызовет следующую ошибку:

Adjacent JSX elements must be wrapped in an enclosing tag

Проблема решается добавлением общего элемента:

<div> 
<div />
     <div />
   </div>
   
Это происходит из-за того, что каждый элемент в JSX транслируется в React.createElement в JavaScript, а в JavaScript нельзя вернуть из функции результат работы двух последовательных вызовов какой-либо функции.

Сейчас React предоставляет возможность использовать пустой тег, чтобы отрисовывать несколько элементов на одном уровне:

render() {
    return (
      <>
        <ChildA />
        <ChildB />
        <ChildC />
      </>
    );
  }
  
\subsubsection*{Spaces}   

Есть еще одна мелочь, которая может вводить в ступор новичков, которая заключается в различной обработке пробельных символов в HTML и JSX.

Например, рассмотрим следующий снипет, который корректен и в HTML и в JSX:

  <div>
     <span>foo</span>
     bar
     <span>baz</span>
</div>

Если открыть этот кусочек напрямую в браузере как HTML файл, то мы увидим foo bar baz. А если мы добавим его в JSX, то после отрисовки будет foobarbaz.

Это происходит из-за того, что JSX воспримет три строки внутри div, как три дочерние элементы и проигнорирует пробельные символы, а после отрисовке все три дочерних элемента будут отрисованы один за другим.

Основной способ исправить это, добавить еще дочерние элементы, которые будут также являться дочерними элементами:

<div>
     <span>foo</span>
     {' '}
     bar
     {' '}
     <span>baz</span>
</div>

Таким образом мы добавляем пустые строки, которые являются JavaScript выражениями, чтобы заставить компилятор добавить новые дочерние элементы.

\subsubsection*{Boolean атрибуты}

Также есть небольшое отличие в использовании boolean атрибутов в JSX. Если передать какой-либо атрибут без значения, то JSX поймет, что это boolean атрибут со значением true:

<button disabled />
   React.createElement("button", { disabled: true });
   
Но в отличие от HTML, чтобы передать атрибут со значением false, необходимо сделать это в явном виде. Если не передать атрибут совсем, то он не попадет в передаваемый объект с атрибутами, и при дальнейшей попытке использования может быть получен undefined вместо false, что приводит к потенциальным ошибкам:

<button disabled={false} />
   React.createElement("button", { disabled: false });
   
Эта особенность может вводить в заблуждение, так как в HTML принято отсутствие атрибута считать как false значение для этого атрибута. В React следует всегда явным образом указывать значение boolean атрибутов.

\subsection*{Spread атрибут}

Важная особенность JSX - \textbf{spread атрибуты}, которая приходит из стандарта ECMASript (https://github.com/sebmarkbage/ecmascript-re st-spread) и очень удобно в случае, когда нам нужно передать все атрибуты JavaScript объекта в параметры элементу.

Распространенная практика - избежать передачи объекта дочерним элементам по ссылке во избежании ошибок, связанных с изменяемостью таких объектов.

В качестве примера можем посмотреть на код:

const foo = { id: 'bar' }
   return <div {...foo} />
   
который будет транслирован в следующий JSX код:

var foo = { id: 'bar' };
   return React.createElement('div', foo);
   
\subsection*{Шабоны JavaScript}

Мы начали с предположения, что одно из преимуществ использования шаблонов внутри наших компонент вместо использования сторонних библиотек шаблонов(прим.пер. видимо имеются ввиду библиотеки-шаблонизаторы как handlebars) в использовании всей мощи языка JavaScript внутри шаблонов.

Spread оператор один из примеров использования JavaScript внутри JSX. Но в целом любое JavaScript выражение может быть использовано как атрибут элемента, для этого достаточно обернуть его в фигурные скобки:

<button disabled={errors.length} />

\subsection*{Основные паттерны}

Мы разобрались с тем, как работает JSX. Теперь мы можем можем подумать детальнее, как использовать JSX, следуя полезным соглашениям и практикам.

\subsubsection*{Многострочный JSX код}

Начнем с простого примера. Одна из причин использовать JSX вместо React.createElement - наглядность XML-like синтаксиса, а также потому что такая структура из отрывающих и закрывающих тегов идеально подходит для описания древовидных структур.

Например, если у нас есть JSX код с множеством вложенных элементов, мы должны предпочитать многострочную запись JSX кода однострочной:

<div>
     <Header />
     <div>
       <Main content={...} />
     </div>
</div>

Такой вариант гораздо предпочтительнее, чем:

<div><Header /><div><Main content={...} /></div></div>

Однако, если дочерний элемент - не React элемент, а текст или переменная, то разумнее будет записать весь тег в одной строке:

<div>
     <Alert>{message}</Alert>
     <Button>Close</Button>
</div>

Также рекомендуется оборачивать все JSX блоки в круглые скобки. Это необходимо делать, чтобы не было проблем с автоматической вставкой точки с запятой. Проблемы могут возникнуть, если например, немного не аккуратно вернуть. JSX разметку из функции.

Следующий пример отработает корректно, так как return и div находятся на одной линии:

return <div />

Но следующий уже отработает непредвиденным образом:

return
     <div />
     
Проблема кроется в том, что во втором случае JSX код будет транслирован в следующий JavaScript код:

return;
React.createElement("div", null);
   
Чтобы избежать таких проблем, рекомендуется всегда оборачивать многострочные JSX элементы в круглые скобки:

return (
     <div />
)

\subsubsection*{Multi-properties}

Небольшой проблемой является также множество атрибутов у элемента. Если записывать атрибуты в одну строку, то она может начать занимать много места в ширину и быть неудобной для чтения. 

Поэтому стоит стараться писать каждый атрибут в новой строке, а закрывающий тег выравнивать с открывающим (прим.пер. также хороший вариант - оставлять закрывающий тег на одной строке с последним атрибутом):

<button
     foo="bar"
     veryLongPropertyName="baz"
     onSomething={this.handleSomething}
/>

\subsubsection*{Условные операторы}

Все гораздо интереснее с использование \textbf{условий} в JSX, например, если нужно отрисовать какой-то компонент только при каком-то условии. С одной стороны возможность использовать JavaScript внутри JSX - большой плюс, но с другой стороны у нас появляется множество вариантов использования условий и нужно знать об их плюсах и минусах.

Предположим, что нам нужно отрисовать кнопку logout только для авторизованного пользователя. Простой вариант решения этой проблемы может выглядеть следующим образом:

let button
   if (isLoggedIn) {
     button = <LogoutButton />
   }
   return <div>{button}</div>
   
Это работает, но этот вариант плохо читается, если у нас есть множество условий и множество элементов.

Также мы можем использовать ленивую проверку логических выражений в JavaScript:

%  <div>
%     {isLoggedIn && <LoginButton />}
%</div>

Это работает, так как в случае false в isLoggedIn JavaScript не будет проверять остальное выражение, а если true, тогда вызовется createElement для LoginButton и результат ее работы вернется как результат всего выражения.

Если мы хотим, чтобы в условии была также альтернативная ветка, например чтобы показать разные кнопки для авторизованного и неавторизованного пользователей, то мы может использовать if...else в JavaScript:


   let button
   if (isLoggedIn) {
     button = <LogoutButton />
   } else {
     button = <LoginButton />
   }
   return <div>{button}</div>
   
Помимо этого мы можем использовать тернарный оператор, чтобы сделать код компактнее:


   <div>
     {isLoggedIn ? <LogoutButton /> : <LoginButton />}
</div>

Можно найти множество примеров использования тернарных операторов в известных репозиториях, например в Redux(https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js\#L25), где он используется для показа разного текста в зависимости от того, грузятся ли данные по сети:

<button [...]>
{isFetching ? 'Loading...' : 'Load More'}
   </button>

Посмотрим, что произойдет, если логическое выражение будет становиться сложнее и в нем будут задействованы разные переменные и логические операции:

%<div>
%    {dataIsReady && (isAdmin || userHasPermissions) &&
%      <SecretData />
    %}
%</div>

Это решение все еще может быть неплохим, но читаемость его начинает падать. Для решения этой проблемы можно создать вспомогательную функцию внутри компонента и использовать ее название для пояснения логики, сокрытой в теле:

%canShowSecretData() {
%     const { dataIsReady, isAdmin, userHasPermissions } = this.props
 %    return dataIsReady && (isAdmin || userHasPermissions)
%}
%   <div>
%     {this.canShowSecretData() && <SecretData />}
%</div>

Код стал более читаемым, и даже если вернуться к нему через полгода, достаточно будет прочесть название функции и опустить чтение логики внутри.

Если вы не любите использовать функцию, то ее можно заменить геттеро, который сделат код более элегантным (прим.пер. а может быть и нет...):

%get canShowSecretData() {
 %    const { dataIsReady, isAdmin, userHasPermissions } = this.props
  %   return dataIsReady && (isAdmin || userHasPermissions)
%}
 %  <div>
  %   {this.canShowSecretData && <SecretData />}
%</div>

То же самое относится к вычисляемым значениям. Например, если у нас есть два значения, валюта и стоимость, и нам нужно объединить их в одну строку, то мы можем вынести эту операцию в отдельный метод.

%getPrice() {
%     return `${this.props.currency}${this.props.value}`
%}
%   <div>{this.getPrice()}</div>

Это также удобнее тестировать, если внутри этого метода есть дополнительная логика.

То же самое можно сделать с помощью геттеров аналогично предыдущим примерам:

%get price() {
%     return `${this.props.currency}${this.props.value}`
%}
%   <div>{this.price}</div>

Есть еще множество решений проблемы ветвления внутри React компонент, которое требует использования сторонних библиотек. В общем случае стоит аккуратно вносить новые зависимости в проект, так как они могут увеличить размер бандла, принести проблему на смене версий и увеличить порог входа в проект, но на что не пойдешь ради увеличения читаемости кода (прим.пер. используемые тут библиотеки довольно просты и имеет смысл реализовать их самостоятельно в учебных целях).

Первый вариант - использовать библиотеку render-if, которую можно установить командой:

\textbf{npm install --save render-if}

Мы можем легко использовать ее в проекте по аналогии с примером ниже:

%const { dataIsReady, isAdmin, userHasPermissions } = this.props
%   const canShowSecretData = renderIf(
 %    dataIsReady && (isAdmin || userHasPermissions)
  % )
   %<div>
    % {canShowSecretData(<SecretData />)}
%</div>

Мы оборачиваем наше условии внутри renderIf функции.

Результатом вызова функции renderIf является функция, которая принимает аргументом React элемент, который она вернет при вызове в случае истинности условия.

Самое главное, что мы не должны забывать в данном контексте, это то, что компоненты должны оставаться простыми и глупыми настолько насколько это возможно. Иначе в этих компонентах будет сложно разбираться, править баги и расширять.

Чтобы сделать компонент чище, мы можем вынести из него логику в Компонент более высокого порядка (Higher-Order Component, HOC) с библиотекой react-only-if. Компоненты выского порядка мы рассмотрем далее в Главе 4, сейчас для нас важно только то, что HOC это функция, которая принимает аргументом компонент, расширяет его или изменяет его поведения и возвращает при вызове.

Данная библиотека устанавливается командой:

\textbf{npm install --save react-only-if}

После установки мы можем использовать ее внутри нашего приложения следующим образом:

%const SecretDataOnlyIf = onlyIf(
%     ({ dataIsReady, isAdmin, userHasPermissions }) => {
%       return dataIsReady && (isAdmin || userHasPermissions)
%     }
%   )(SecretData)
%   <div>
%     <SecretDataOnlyIf
%       dataIsReady={...}
%       isAdmin={...}
%       userHasPermissions={...}
%/> </div>

Как можно заметить, в этом случае внутри исходного компонента нет логики совсем, что повышает его тестируемость.

Мы передаем условие как параметр в функцию onlyIf, которая меняет поведение нашего компонента таким образом, чтобы оно отображалось только в случае истинности логического выражения.

\subsubsection*{Циклы}

Отображения списков элементов - очень распространенная операция. И в данном случае JavaScript показывает себя с хорошей стороны.

Если мы поместим внутрь JSX массив с React элементами, то все они будут отрисованы на одном уровне вложенности. В целом для нас не важно, как будет получен этот массив, главное, чтобы как и любое другое выражение, было помещено в фигурные скобки.

Самым распространенным способом создать массив элементов является использование операций над множествами объектов языка JavaScript:

%<ul>
%     {users.map(user =><li>{user.name}</li>)}
%</ul>

Этот пример прост, но показывает большую гибкость использования JSX и JavaScript для генерации HTML.

\subsubsection*{Control statements}

Условные операторы и циклы часто используются для описания верстки и, возможно, вам может показаться, что вносить в JSX блоки JavaScript кода для таких базовых операция - не лучшая практика. Но JSX был разработан лишь как инструмент генерации элементов, оставляя работы с логикой программы на JavaScript.

В общем и целом не стоит держать большой объем логики внутри компонент, но тем не менее время от времени нам нужно скрывать или показывать элементы в зависимости от состояния или итерировать коллекции объектов для отображения списков. 

Если вы чувствуете, что JSX должен также позволять использовать условия и циклы, и это сделает код более читаемым, то вы можете попробовать библиотеку: jsx-control-statements.

Эта библиотека не приносит никакого нового функционала в JSX и являешься лишь синтаксическим сахаром, который компилируется в JavaScript.

Прежде всего нам нужно добавить ее в проет:

\textbf{npm install --save jsx-control-statements}

Также его необходимо добавить в .babelrc, чтобы babel знал, что у нас появились новые правила компиляции:

"plugins": ["jsx-control-statements"]

С этого момента мы можем использовать новый синтакс и babel будет транслировать его вместе со стандартным JSX.

Условноый оператор, написанный с использование этого плагина, будет выглядеть следующим образом:

%<If condition={this.canShowSecretData}>
%     <SecretData />
%</If>

Этот код будет транслирован в обычный тернарный оператор в JavaScript:

%{canShowSecretData ? <SecretData /> : null}

Для ситуации, когда нам нужно иметь возможность выбрать элемент из нескольких в зависимости от различных условий, в данной библиотеке есть компонент Choose:

%<Choose>
%     <When condition={...}>
%       <span>if</span>
%     </When>
%     <When condition={...}>
%       <span>else if</span>
%     </When>
%     <Otherwise>
%       <span>else</span>
%     </Otherwise>
%</Choose>

Не стоит забывать, что компоненты Choose, When и Otherwise не являются React компонентами в привычном для нас понимании, это всего лишь синтаксис, который будет скомпилирован в большой набор тернарных операторов.

Также есть специальный компонент For (который также будет скомпилирован в JavaScript код) для работы с коллекциями объектов:

%<ul>
%     <For each="user" of={this.props.users}>
%       <li>{user.name}</li>
%     </For>
%</ul>

Тут тоже никакой магии, после компиляции этот блок превратится в вызов метода map.

Если вы используете какой-либо линтер, то он может ругаться в последнем случае, так как переменная user по сути не определена. Это происходит из-за того, что объявление этой переменной будет сгенерировано после компиляции.

Если вы используете eslint, то для исключения данной ошибки проверки кода можно использовать библиотеку eslint- plugin-jsx-control-statements.

Если у вас еще нет опыта использования линтеров, то не беспокойтесь, они будут разобраны чуть позже. 

\subsubsection*{Sub-rendering}

В общем случае стоит стараться делать компоненты маленькими и простыми насколько это возможно, но тем не менее компоненты могут начать разбухать, особенно если разработка идет итеративно и функционал наращивается понемногу на каждой итерации.

Что мы можем сделать, если наши методы отображения компонент становятся слишком большими. Один из вариантов - разделить большой метод render на небольшие функции внутри одного компонента:

% renderUserMenu() {
%     // JSX for user menu
%}
%   renderAdminMenu() {
%     // JSX for admin menu
%}
%   render() {
%     return (
%       <div>
%         <h1>Welcome back!</h1>
%         {this.userExists && this.renderUserMenu()}
%         {this.userIsAdmin && this.renderAdminMenu()}
%</div> )
%}

Это далеко не идеальное решение, но на практике, если нет возможности разделить компонент на более мелкие, это позволяет сохранять метод render чище.

Теперь мы должны начать чувствовать себя посвободнее в использовании JSX. Можно перейти к вопросу, как следовать единому стилю кода внутри всего проекта.

\section{ESLint}

\end{document}










