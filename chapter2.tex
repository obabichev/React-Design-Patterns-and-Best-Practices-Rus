\chapter{Делаем код чище}

Чтобы использовать JSX без проблем, необходимо понимать, как он работает под капотом и почему его удобно использовать для создания интерфейса.

Наша цель -- писать чистый и поддерживаемый JSX код, и для этого мы должны знать, как JSX транслируется в JavaScript код и какие предоставляет фичи.

В этом блоке мы разберем:

\begin{itemize}
  \item Что такое JSX и почему мы должны его использовать
  \item Что такое Babel и как он используется в современной разработке
  \item Основные фичи JSX и его отличие от HTML
  \item Лучшие практики при написании кода на JSX
  \item Статическую проверку кода с ESLint 
  \item Основы функционального программирования и его применение в создании React компонент
\end{itemize}


\section{JSX}

React предлагает два основных способа описания элементов: использование библиотечных JavaScript функций и использование JSX разметки, похожей на XML. 

На первый взгляд может показаться, что JSX - это странная смесь из HTML и JavaScript. Но на деле, JSX разметка перед попаданием в браузер конвертируется в чистый JavaScript. Этот прием позволяет достаточно лаконично и визуально понятно описывать компоненты.

\subsection{Babel}

Чтобы использовать JSX(а также фичи ES2015) нам необходимо установить Babel. 

Важно понимать, почему мы добавляем Babel в наш процесс разработки. Основная причина в желании использовать фичи языка, которые еще не доступны в браузере. Новые фичи языка часто помогают нам писать код чище и понятнее, но браузер не может их исполнить.

Решение -- писать код с JSX и ES2015, а затем транслировать в ES5, который сейчас могут запускать большинство браузеров, используя Babel.

Чтобы использовать Babel, его необходимо установить:

\begin{lstlisting}[language=bash]
	npm install --global babel-cli
\end{lstlisting}

Чтобы не загромождать npm пакетами систему, можно установить babel в конкретный проект и использовать через npm скрипты. Но для учебных целей установим его глобально.

После установки мы можем транслировать любой JavaScript файл:

\begin{lstlisting}[language=bash]
	babel source.js -o output.js
\end{lstlisting}

Одна из сильных сторон Babel - возможность его гибкой конфигурации. Babel всего лишь транслирует один файл в другой, а чтобы были произведены изменения содержимого, нужно сконфигурировать этот процесс.

Для Babel уже создано множество пресетов, в том числе и для JSX и ES2015. Чтобы установить их, необходимо выполнить:

\begin{lstlisting}[language=bash]
npm install --global babel-preset-es2015 babel-preset-react	
\end{lstlisting}

а также добавить в домашнюю директорию (или в папку с проектом) файл .babelrc с содержимым:

\begin{lstlisting}[language=JavaScript]
{
  "presets": [
    "es2015",
    "react" 
  ]
}

\end{lstlisting}

С этого момента мы можем спокойно использовать все фичи ES2015 и JSX, а потом запускать в браузере транслированный Babel'ем код.

\subsection{Hello, World}

Посмотрим на простейший пример создание элемента в React. 

Мы можем создать \textit{div} элемент с помощью метода \textit{createElement} библиотеки React:

\begin{lstlisting}
	React.createElement('div')
\end{lstlisting}

Также мы можем создать его, используя JSX:

\begin{lstlisting}
	<div />
\end{lstlisting}

В данном примере JSX код выглядит как HTML. Но нужно понимать одну важную вещь, оба варианта, написанные выше, эквивалентны. 

На самом деле, если мы транслируем <div /> в JavaScript при помощи babel, то мы получим React.createElement('div'). Это необходимо всегда держать в голове при описании интерфейса на React.

\subsection{DOM элементы и React компоненты}

C JSX мы можем создавать и HTML элементы и React элементы. Разница лишь в том, пишем мы название элемента с заглавной буквы или нет.

Например, в JSX мы можем создать <button /> и <Button /> элементы.

В первом случае результатом трансляции будет:

\begin{lstlisting}
React.createElement('button')
\end{lstlisting}

Во втором случае:

\begin{lstlisting}
React.createElement(Button)
\end{lstlisting}

Разница в том, что в первом случае тип DOM элемента передается как строка, а во втором случае мы передаем название переменной, которая должна быть как минимум определена в области видимости данного кода.

\subsection{Props}

JSX очень удобен, если у DOM или React компонентов есть параметры. В XML в целом гораздо нагляднее передавать параметры элементам:
   
\begin{lstlisting}
<img src="https://facebook.github.io/react/img/logo.svg"
   alt="React.js" />
\end{lstlisting}

Аналогичный код на JavaScript:

\begin{lstlisting}
React.createElement("img", {
     src: "https://facebook.github.io/react/img/logo.svg",
     alt: "React.js"
});
\end{lstlisting}

Читаемость резко падает даже с небольшим количеством параметров.

\subsection{Children}

JSX позволяет определять дочерние элементы, чтобы создавать комплексные древовидные разметки.

Простой пример дочернего элемента -- текст внутри тега:

\begin{lstlisting}
<a href="https://facebook.github.io/react/">Click me!</a>
\end{lstlisting}

Этот пример будет транслирован в:

\begin{lstlisting}
React.createElement(
  "a",
  { href: "https://facebook.github.io/react/" },
  "Click me!"
);
\end{lstlisting}
   
Если этот тег обернуть в другой, например div, то JSX будет выглядеть как:

\begin{lstlisting}
<div>
  <a href="https://facebook.github.io/react/">Click me!</a>
</div>
\end{lstlisting}

JavaScript эквивалентный этому JSX:

\begin{lstlisting}
React.createElement(
  "div",
  null,
  React.createElement(
    "a",
    { href: "https://facebook.github.io/react/" },
    "Click me!"
  ) 
);
\end{lstlisting}

Достаточно очевидно, что чем сложнее разметка, тем больше JSX улучшает читаемость кода. Однако не следует забывать, что каждому JSX коду соответствует однозначно определенный код на JavaScript.

Так как JSX всего лишь удобный синтаксис для JavaScript, вполне логично, что в нем можно использовать JavaScript выражения. 

Для того, чтобы сделать это, выражение должно быть обернуто в фигурные скобки:

\begin{lstlisting}
<div>
  Hello, {variable}.
  I'm a {function()}.
</div>	
\end{lstlisting}


Или например в параметрах элемента:

\begin{lstlisting}
<a href={this.makeHref()}>Click me!</a>
\end{lstlisting}

\subsection{Differences with HTML}

Мы посмотрели, чем похожи JSX и HTML. Теперь посмотрим в чем они отличаются и в чем причины этих различий.

\subsubsection{Аттрибуты}

Мы должны помнить, что JSX не стандарт языка, и транслируется в JavaScript. Из-за этого некоторые атрибуты не доступны для использования.

Например, вместо атрибута class мы вынуждены использовать className, а вместо for использовать htmlFor:

\begin{lstlisting}
<label className="awesome-label" htmlFor="name" />
\end{lstlisting}

Причина этого в том, что слова class и for зарезервированы в языке JavaScript.

\subsubsection{Стили}

Стили -- пример значительных различий между HTML и JSX. Подробнее мы посмотрим на них в одной из следующих глав. 

Сейчас отметим, что через JSX в атрибуте style не поддерживается CSS строка. Вместо нее React ожидает JavaScript объект, в котором имена стилей переданы в camelCase:

\begin{lstlisting}
<div style={{ backgroundColor: 'red' }} />
\end{lstlisting}

\subsubsection{Root}

Стоит отметить важное отличие JSX от HTML, которое заключается в том, что нельзя создать несколько элементов на одном уровне без оборачивания другим элементом:

\begin{lstlisting}
<div />
<div />
\end{lstlisting}

Этот пример вызовет следующую ошибку:

Adjacent JSX elements must be wrapped in an enclosing tag

Проблема решается добавлением общего элемента:

\begin{lstlisting}
<div> 
  <div />
  <div />
</div>
\end{lstlisting}
   
Это происходит из-за того, что каждый элемент в JSX транслируется в React.createElement в JavaScript, а в JavaScript нельзя вернуть из функции результат работы двух последовательных вызовов какой-либо функции.

Сейчас React предоставляет возможность использовать пустой тег, чтобы отрисовывать несколько элементов на одном уровне:

\begin{lstlisting}
render() {
  return (
    <>
      <ChildA />
      <ChildB />
      <ChildC />
    </>
  );
}
\end{lstlisting}
  
\subsubsection{Spaces}   

Есть еще одна мелочь, которая может вводить в ступор новичков, заключается в различной обработке пробельных символов в HTML и JSX.

Например, рассмотрим следующий пример кода, который корректен и в HTML и в JSX:

\begin{lstlisting}
<div>
  <span>foo</span>
  bar
  <span>baz</span>
</div>
\end{lstlisting}

Если открыть этот кусочек напрямую в браузере как HTML файл, то мы увидим foo bar baz. А если мы добавим его в JSX, то после отрисовки будет foobarbaz.

Это происходит из-за того, что JSX воспримет три строки внутри div, как три дочерние элементы и проигнорирует пробельные символы, а после отрисовке все три дочерних элемента будут отрисованы один за другим.

Основной способ исправить это, добавить еще дочерние элементы, которые будут также являться дочерними элементами:

\begin{lstlisting}
<div>
  <span>foo</span>
  {' '}
  bar
  {' '}
  <span>baz</span>
</div>
\end{lstlisting}

Таким образом мы добавляем пустые строки, которые являются JavaScript выражениями, чтобы заставить компилятор добавить новые дочерние элементы.

\subsubsection{Boolean атрибуты}

Также есть небольшое отличие в использовании boolean атрибутов в JSX. Если передать какой-либо атрибут без значения, то JSX поймет, что это boolean атрибут со значением true:

\begin{lstlisting}
<button disabled />
\end{lstlisting}

\begin{lstlisting}
React.createElement("button", { disabled: true });
\end{lstlisting}
   
Но в отличие от HTML, чтобы передать атрибут со значением false, необходимо сделать это в явном виде. Если не передать атрибут совсем, то он не попадет в передаваемый объект с атрибутами, и при дальнейшей попытке использования может быть получен undefined вместо false, что приводит к потенциальным ошибкам:

\begin{lstlisting}
<button disabled={false} />
\end{lstlisting}

\begin{lstlisting}
React.createElement("button", { disabled: false });
\end{lstlisting}
   
Эта особенность может вводить в заблуждение, так как в HTML принято отсутствие атрибута считать как false значение для этого атрибута. В React следует всегда явным образом указывать значение boolean атрибутов.

\subsection{Spread атрибут}

Важная особенность JSX - \textbf{spread атрибуты}, она приходит из стандарта ECMASript (https://github.com/sebmarkbage/ecmascript-re st-spread) и очень удобна в случае, когда нам нужно передать все атрибуты JavaScript объекта в параметры элементу.

Распространенная практика -- избегать передачи объекта дочерним элементам по ссылке во избежание ошибок, связанных с изменяемостью таких объектов.

В качестве примера можем посмотреть на код:

\begin{lstlisting}
const foo = { id: 'bar' }
return <div {...foo} />
\end{lstlisting}
   
который будет транслирован в следующий JSX код:

\begin{lstlisting}
var foo = { id: 'bar' };
return React.createElement('div', foo);
\end{lstlisting}
   
\subsection{Шаблоны JavaScript}

Мы предположили, что использование компонентов позволяет объединить шаблон страницы и JavaScript код, чего не позволяют делать сторонние библиотеки (прим.пер. видимо имеются ввиду библиотеки шаблонизаторы, такие, как handlebars).

Spread оператор -- это один из примеров использования JavaScript внутри JSX. Но в целом любое JavaScript выражение может быть использовано как атрибут элемента. Для этого достаточно обернуть его в фигурные скобки:

\begin{lstlisting}
<button disabled={errors.length} />
\end{lstlisting}

\subsection{Основные паттерны}

Мы разобрались с тем, как работает JSX. Теперь мы можем подумать более подробно, как использовать JSX, следуя полезным соглашениям и практикам.

\subsubsection{Многострочный JSX код}

Начнем с простого примера. Две причины использовать JSX вместо React.createElement - наглядность XML-like синтаксиса и структура из отрывающих и закрывающих тегов, которая идеально подходит для описания древовидных структур.

Например, если у нас есть JSX код с множеством вложенных элементов, мы должны предпочитать многострочную запись JSX кода однострочной:

\begin{lstlisting}
<div>
  <Header />
  <div>
    <Main content={...} />
  </div>
</div>
\end{lstlisting}

Такой вариант гораздо предпочтительнее, чем:

\begin{lstlisting}
<div><Header /><div><Main content={...} /></div></div>
\end{lstlisting}

Однако, если дочерний элемент -- не React элемент, а текст или переменная, то разумнее будет записать весь тег в одной строке:

\begin{lstlisting}
<div>
  <Alert>{message}</Alert>
  <Button>Close</Button>
</div>
\end{lstlisting}

Также рекомендуется оборачивать все JSX блоки в круглые скобки. Это необходимо делать, чтобы не было проблем с автоматической вставкой точки с запятой. Проблемы могут возникнуть, если, например, немного не аккуратно вернуть JSX разметку из функции.

Следующий пример отработает корректно, так как return и div находятся на одной линии:

\begin{lstlisting}
return <div />
\end{lstlisting}

Но следующий уже отработает непредвиденным образом:

\begin{lstlisting}
return
     <div />
\end{lstlisting}
     
Проблема кроется в том, что во втором случае JSX код будет транслирован в следующий JavaScript код:

\begin{lstlisting}
return;
React.createElement("div", null);
\end{lstlisting}
   
Чтобы избежать таких проблем, рекомендуется всегда оборачивать многострочные JSX элементы в круглые скобки:

\begin{lstlisting}
return (
  <div />
)
\end{lstlisting}

\subsubsection{Multi-properties}

Небольшой проблемой является также наличие множества атрибутов у элемента. Если записывать атрибуты в одну строку, то она может занимать много места в ширину и быть неудобной для чтения. 

Поэтому стоит стараться писать каждый атрибут в новой строке, а закрывающий тег выравнивать с открывающим (прим.пер. также хороший вариант -- оставлять закрывающий тег на одной строке с последним атрибутом):

\begin{lstlisting}
<button
  foo="bar"
  veryLongPropertyName="baz"
  onSomething={this.handleSomething}
/>
\end{lstlisting}

\subsubsection{Условные операторы}

Все гораздо интереснее с использованием \textbf{условий} в JSX, например, если нужно отрисовать какой-то компонент только при каком-то условии. С одной стороны возможность использовать JavaScript внутри JSX - большой плюс, но с другой стороны у нас появляется множество вариантов использования условий и нужно знать об их плюсах и минусах.

Предположим, что нам нужно отрисовать кнопку logout только для авторизованного пользователя. Простой вариант решения этой проблемы может выглядеть следующим образом:

\begin{lstlisting}
let button
if (isLoggedIn) {
  button = <LogoutButton />
}
return <div>{button}</div>
\end{lstlisting}
   
Это работает, но этот вариант плохо читается, если у нас есть множество условий и множество элементов.

Также мы можем использовать ленивую проверку логических выражений в JavaScript:

\begin{lstlisting}
<div>
  {isLoggedIn && <LoginButton />}
</div>
\end{lstlisting}

Это работает, так как в случае false в isLoggedIn JavaScript не будет проверять остальное выражение, а если true, тогда вызовется createElement для LoginButton и результат ее работы вернется как результат всего выражения.

Если мы хотим, чтобы в условии была также альтернативная ветка, например, чтобы показать разные кнопки для авторизованного и неавторизованного пользователей, то мы может использовать if...else в JavaScript:

\begin{lstlisting}
let button
if (isLoggedIn) {
  button = <LogoutButton />
} else {
  button = <LoginButton />
}
return <div>{button}</div>
\end{lstlisting}
   
Помимо этого мы можем использовать тернарный оператор, чтобы сделать код компактнее:

\begin{lstlisting}
<div>
  {isLoggedIn ? <LogoutButton /> : <LoginButton />}
</div>
\end{lstlisting}

Можно найти множество примеров использования тернарных операторов в известных репозиториях, например, в \href{https://github.com/reactjs/redux/blob/master/examples/real-world/src/components/List.js\#L25}{Redux}, где он используется для показа разного текста в зависимости от того, грузятся ли данные по сети:

\begin{lstlisting}
<button [...]>
  {isFetching ? 'Loading...' : 'Load More'}
</button>
\end{lstlisting}

Посмотрим, что произойдет, если логическое выражение будет становиться сложнее и в нем будут задействованы разные переменные и логические операции:

\begin{lstlisting}
<div>
  {dataIsReady && (isAdmin || userHasPermissions) && 
    <SecretData />
}
</div>
\end{lstlisting}

Это решение все еще может быть неплохим, но читаемость его начинает падать. Для решения этой проблемы можно создать вспомогательную функцию внутри компонента и использовать ее название для пояснения логики, сокрытой в теле:

\begin{lstlisting}
canShowSecretData() {
  const { dataIsReady, isAdmin, userHasPermissions } = this.props
  return dataIsReady && (isAdmin || userHasPermissions)
}
<div>
  {this.canShowSecretData() && <SecretData />}
</div>
\end{lstlisting}

Код стал более читаемым, и, даже если вернуться к нему через полгода, достаточно будет прочесть название функции и опустить чтение логики внутри.

Если вы не любите использовать функции, то ее можно заменить геттером, который сделает код более элегантным (прим.пер. а может быть и нет...):

\begin{lstlisting}
get canShowSecretData() {
  const { dataIsReady, isAdmin, userHasPermissions } = this.props
  return dataIsReady && (isAdmin || userHasPermissions)
}
<div>
  {this.canShowSecretData && <SecretData />}
</div>
\end{lstlisting}

То же самое относится к вычисляемым значениям. Например, если у нас есть два значения: валюта и стоимость; и нам нужно объединить их в одну строку, то мы можем вынести эту операцию в отдельный метод.

\begin{lstlisting}
getPrice() {
  return `${this.props.currency}${this.props.value}`
}
<div>{this.getPrice()}</div>
\end{lstlisting}

Это также удобнее тестировать, если внутри этого метода есть дополнительная логика.

То же самое можно сделать с помощью геттеров аналогично предыдущим примерам:

\begin{lstlisting}
get price() {
  return `${this.props.currency}${this.props.value}`
}
<div>{this.price}</div>
\end{lstlisting}

Есть еще множество решений проблемы ветвления внутри React компонент, которое требует использования сторонних библиотек. В общем случае стоит аккуратно вносить новые зависимости в проект, так как они могут увеличить размер бандла, принести проблему на смене версий и увеличить порог входа в проект, но на что не пойдешь ради увеличения читаемости кода (прим.пер. используемые тут библиотеки довольно просты и имеет смысл реализовать их самостоятельно в учебных целях).

Первый вариант - использовать библиотеку render-if, которую можно установить командой:
\begin{lstlisting}[language=bash]
npm install --save render-if
\end{lstlisting}

Мы можем легко использовать ее в проекте по аналогии с примером ниже:

\begin{lstlisting}
const { dataIsReady, isAdmin, userHasPermissions } = this.props
const canShowSecretData = renderIf(
  dataIsReady && (isAdmin || userHasPermissions)
)
<div>
  {canShowSecretData(<SecretData />)}
</div>
\end{lstlisting}


Мы оборачиваем наше условие внутри renderIf функции.

Результатом вызова функции renderIf является функция, которая принимает аргументом React элемент. Этот элемент будет возвращен в случае истинности условия.

Самое главное, что мы не должны забывать в данном контексте, это то, что компоненты должны оставаться простыми и глупыми настолько, насколько это возможно. Иначе в этих компонентах будет сложно разбираться, править баги и расширять.

Чтобы сделать компонент чище, мы можем вынести из него логику в Компонент Более Высокого Порядка (Higher-Order Component, HOC) с библиотекой react-only-if. Компоненты высокого порядка мы рассмотрим  в Главе 4. Сейчас для нас важно то, что HOC - это функция, которая принимает аргументом компонент, расширяет его функционал и возвращает обратно при вызове.

Данная библиотека устанавливается командой:

\begin{lstlisting}[language=bash]
npm install --save react-only-if
\end{lstlisting}

После установки мы можем использовать ее внутри нашего приложения следующим образом:

\begin{lstlisting}
const SecretDataOnlyIf = onlyIf(
  ({ dataIsReady, isAdmin, userHasPermissions }) => {
    return dataIsReady && (isAdmin || userHasPermissions)
  }
)(SecretData)
<div>
  <SecretDataOnlyIf
    dataIsReady={...}
    isAdmin={...}
    userHasPermissions={...}
  /> 
</div>
\end{lstlisting}

Как можно заметить, в этом случае внутри исходного компонента нет логики совсем, что повышает его тестируемость.

Мы передаем условие как параметр в функцию onlyIf, которая меняет поведение нашего компонента таким образом, чтобы оно отображалось только в случае истинности логического выражения.

\subsubsection{Циклы}

Отображения списков элементов -- очень распространенная операция. И в данном случае JavaScript показывает себя с хорошей стороны.

Если мы поместим внутрь JSX массив с React элементами, то все они будут отрисованы на одном уровне вложенности. В целом для нас не важно, как будет получен этот массив, главное, чтобы, как и любое другое выражение, он был помещен в фигурные скобки.

Самым распространенным способом создать массив элементов является использование операций над множествами объектов языка JavaScript:

\begin{lstlisting}
<ul>
  {users.map(user =><li>{user.name}</li>)}
</ul>
\end{lstlisting}

Этот пример прост, но показывает большую гибкость использования JSX и JavaScript для генерации HTML.

\subsubsection{Control statements}

Условные операторы и циклы часто используются для описания верстки и, возможно, вам может показаться, что вносить в JSX блоки JavaScript кода для таких базовых операций -- не лучшая практика. Но JSX был разработан лишь как инструмент генерации элементов, оставляя работу с логикой программы на JavaScript.

В общем и целом не стоит держать большой объем логики внутри компонентов, тем не менее иногда нам нужно скрывать или показывать элементы в зависимости от состояния или итерировать коллекции объектов для отображения списков.

Если вы чувствуете, что JSX должен также позволять использовать условия и циклы, и это сделает код более читаемым, то вы можете попробовать библиотеку: jsx-control-statements.

Эта библиотека не приносит никакого нового функционала в JSX и являешься лишь синтаксическим сахаром, который компилируется в JavaScript.

Прежде всего нам нужно добавить ее в проект:

\begin{lstlisting}[language=bash]
npm install --save jsx-control-statements
\end{lstlisting}

Также его необходимо добавить в .babelrc, чтобы babel знал, что у нас появились новые правила компиляции:

\begin{lstlisting}
"plugins": ["jsx-control-statements"]
\end{lstlisting}

С этого момента мы можем использовать новый синтаксис и babel будет транслировать его вместе со стандартным JSX.

Условный оператор, написанный с использованием этого плагина, будет выглядеть следующим образом:

\begin{lstlisting}
<If condition={this.canShowSecretData}>
  <SecretData />
</If>
\end{lstlisting}

Этот код будет транслирован в обычный тернарный оператор в JavaScript:

\begin{lstlisting}
{canShowSecretData ? <SecretData /> : null}
\end{lstlisting}

Для ситуации, когда нам нужно иметь возможность выбрать элемент из нескольких в зависимости от различных условий, в данной библиотеке есть компонент Choose:

\begin{lstlisting}
<Choose>
  <When condition={...}>
    <span>if</span>
  </When>
  <When condition={...}>
    <span>else if</span>
  </When>
  <Otherwise>
    <span>else</span>
  </Otherwise>
</Choose>
\end{lstlisting}

Не стоит забывать, что компоненты Choose, When и Otherwise не являются React компонентами в привычном для нас понимании, это всего лишь синтаксис, который будет скомпилирован в большой набор тернарных операторов.

Также есть специальный компонент For (который также будет скомпилирован в JavaScript код) для работы с коллекциями объектов:

\begin{lstlisting}
<ul>
  <For each="user" of={this.props.users}>
    <li>{user.name}</li>
  </For>
</ul>
\end{lstlisting}

Тут тоже никакой магии, после компиляции этот блок превратится в вызов метода map.

Если вы используете какой-либо линтер, то он может ругаться в последнем случае, так как переменная user по сути не определена. Это происходит из-за того, что объявление этой переменной будет сгенерировано после компиляции.

Если вы используете eslint, то для исключения данной ошибки проверки кода можно использовать библиотеку eslint- plugin-jsx-control-statements.

Если у вас еще нет опыта использования линтеров, то не беспокойтесь, они будут разобраны чуть позже. 

\subsubsection{Sub-rendering}

В общем случае стоит стараться делать компоненты маленькими и простыми насколько это возможно, тем не менее компоненты могут начать разбухать, особенно если разработка идет итеративно, и функционал наращивается понемногу на каждой итерации.

Что мы можем сделать, если наши методы отображения компонент становятся слишком большими? Один из вариантов -- разделить большой метод render на небольшие функции внутри одного компонента:

\begin{lstlisting}
renderUserMenu() {
    // JSX for user menu
}
renderAdminMenu() {
    // JSX for admin menu
}
render() {
  return (
    <div>
      <h1>Welcome back!</h1>
      {this.userExists && this.renderUserMenu()}
      {this.userIsAdmin && this.renderAdminMenu()}
    </div> 
  )
}
\end{lstlisting}

Это далеко не идеальное решение, но на практике, если нет возможности разделить компонент на более мелкие, это позволяет сохранять метод render чище.

Теперь мы должны начать чувствовать себя посвободнее в использовании JSX. Можно перейти к вопросу, как следовать единому стилю кода внутри всего проекта.

\section{ESLint}

Мы всегда пытаемся писать лучший код, на который способны, но все равно время от времени делаем ошибки и тратим часы на их поиск и исправление.

К счастью для нас, есть инструменты, которые позволяют искать ошибки еще на стадии написания кода. Такие инструменты не скажут, делает ли код то, что должен, но как минимум помогут избежать синтаксических ошибок.

Если вы пришли из мира языков со статической типизацией, таких как C\#, то вы привыкли, что множество синтаксических ошибок можно обнаружить в IDE во время написания кода.

Дуглас Крокфорд (Douglas Crockford) сделал линтинг (статическую проверку кода) популярным в мире JavaScript с инструментом JSLint(первый релиз в 2002). Дальше этот инструмент перерос в JSHint, а затем в ESLint, став основным инструментом статической проверки кода в JavaScript мире в целом и в React разработке в частности.

\textbf{ESLint} - инструмент с открытым исходным кодом, вышедший в 2013 году и быстро набравший популярность за счет гибкости в настройке и расширении.

В мире JavaScript, где постоянно меняются библиотеки и подходы, возможность гибкой конфигурации стала одной из главных причин быстрого распространения ESLint. 

Помимо этого сейчас мы транслируем код с помощью babel и используем новые возможности языка и сторонние расширения, такие как JSX. Плюс ESLint в том, что он позволяет дописывать расширения для проверки любого нового синтаксиса.

Помимо этого, так как ESLint позволяет создавать правила для проверки синтаксиса, у нас появляется возможность определить единый стиль кода внутри больших команд.


\subsection{Установка}

Прежде всего нам нужно установить ESLint:

\begin{lstlisting}
npm install --global eslint
\end{lstlisting}

После этого мы можем запустить его следующей командой:

\begin{lstlisting}
eslint source.js
\end{lstlisting}

На выходе мы получим информацию об ошибках внутри файла с кодом.

Но при первом запуске мы не должны увидеть никаких ошибок, потому ESLint не содержит никаких правил проверки по умолчанию.

\subsection{Настройка}

Для настройки ESLint используется файл $.eslintrc$ в домашней директории проекта или пользователя.

Начнем с простого и запретим использовать символ точки с запятой. Для этого добавим в .eslintrc следующий JSON:

\begin{lstlisting}
{
  "rules": {
    "semi": [2, "never"]
  } 
}
\end{lstlisting}

Эта запись определенно требует некоторых пояснений: $"semi"$ - название правила(rule), а $[2, "never"]$ - его значение. 

В ESLint каждому правилу можно задать один из 3 уровней строгости:

\begin{itemize}
  \item \textbf{off (0): Правило выключено}
  \item \textbf{warn (1): Правило предупреждения}
  \item \textbf{error (2): Правило ошибки}
\end{itemize}

Таким образом, указав в нашем примере значение 2, мы говорим, что ESLint, при срабатывании этого правила, должен ругаться о наличии ошибки в коде.

Второй параметр ($"never"$) говорит о том, что точка с запятой никогда не должна использоваться внутри проекта.

ESLint и его плагины хорошо документированы и можно всегда посмотреть, как именно работают правила, и что значат их аргументы.

Теперь создадим файл index.js со следующим содержимым:

\begin{lstlisting}
var foo = 'bar';
\end{lstlisting}

(Мы используем $var$ так как ESLint еще не знает о том, что мы собираемся использовать ES2015).

Если мы запустим $eslint index.js$, то получим следующее сообщение:

$$\textbf{Extra semicolon (semi)}$$

Заработало, теперь мы можем добавлять правила и следовать (или не следовать) им внутри проекта.

Мы можем добавлять все правила вручную или включить рекомендованный набор правил одной строкой в .eslintrc:

\begin{lstlisting}
{
  "extends": "eslint:recommended"
}
\end{lstlisting}

После этого каждое отдельное правило может быть изменено по необходимости вручную.

После применения рекомендованных правил мы должны перестать получать ошибку о наличии точки с запятой (т.к. это правило не входит в рекомендованные), но должны получить ошибку, что переменная $foo$ объявлена, но никогда не используется.

Правило $no-unused-vars$ очень полезно для сохранения чистоты кодовой базы.

Вспомним, что мы хотим писать код на ES2015, но если мы изменим исходный код на следующий:

\begin{lstlisting}
const foo = 'bar'
\end{lstlisting}

То получим следующую ошибку:

$$
\textbf{Parsing error: The keyword 'const' is reserved}
$$

Для того, чтобы включить поддержку ES2015, мы должны добавить информацию об этом в .eslintrc:

\begin{lstlisting}
"parserOptions": {
  "ecmaVersion": 6,
}
\end{lstlisting}

Также для нас будет полезно указать, что мы используем JSX:

\begin{lstlisting}
"parserOptions": {
  "ecmaVersion": 6,
  "ecmaFeatures": {
    "jsx": true 
  }
},
\end{lstlisting}

Если вы уже писали приложения на React, но не использовали линтер, то хорошим упражнением будет добавить ESLint в уже существующий проект и исправить все ошибки, которые будут найдены.

Использование ESLint из консоли конечно позволяет нам проверять код, но еще одним плюсом этого инструмента является то, что он поддерживается большинством современных редакторов и IDE (SublimeText, Atom и множество других).

Очень часто есть сильный соблазн просто проигнорировать все, что говорит нам ESLint и залить код в общий репозиторий. Чтобы избежать этого, имеет смысл добавить линтер как один из шагов в процесс сборки приложения, в этом случае код с ошибками просто не попадет в продакшн.

Еще один вариант, добавить линтер на этап создания запроса на изменения (pull request). В этом случае код с ошибками не попадет даже на ревью кода.

\subsection{React плагин}

Как было сказано раньше, одна из сильнейших сторон ESLint - его расширяемость плагинами. Самый важный плагин для нас eslint-plugin-react.

В целом ESLint может работать с JSX без дополнительных плагинов. Но мы хотим больше, например хранить наши компоненты в одном определенном стиле.

Прежде всего нам нужно установить плагин:

\begin{lstlisting}
npm install --global eslint-plugin-react
\end{lstlisting}
   
После этого мы можем добавить его в наш файл с настройками:

\begin{lstlisting}
"plugins": [
  "react"
]
\end{lstlisting}

По аналогии с самим ESLint мы можем добавить набор рекомендованных настроек для react плагина:

\begin{lstlisting}
"extends": [
  "eslint:recommended",
  "plugin:react/recommended"
],
\end{lstlisting}

С этого момента, если что-то будет не так с нашими компонентами, например мы попробуем передать один и тот же параметр дважды, ESLint будет предупреждать об ошибке:

\begin{lstlisting}
<Foo bar bar />
\end{lstlisting}

И соответствующее сообщение об ошибке:

$$
\textbf{No duplicate props allowed (react/jsx-no-duplicate-props)}
$$

Есть множество правил, которые мы можем использовать в нашем проекте. Давайте посмотрим, как некоторые из них могут улучшить нашу жизнь.

Одна из проблем, которую может помочь решить для нас ESLint, - это одинаковый размер отступов в JSX верстке. Это поможет нам сохранить единый стиль внутри всего приложения и не держать постоянно в голове точный размер отступов.

Для того, чтобы включить эту проверку, достаточно добавить следующее правило:

\begin{lstlisting}
"rules": {
  "react/jsx-indent": [2, 2]
}
\end{lstlisting}

Первая $2$ означает, что ESLint будет говорить об ошибке, если сработает это правило, вторая $2$ говорит от том, что размер отступа для каждого компонента должен быть из двух пробелов. Также можно сказать, что отступов не должно быть вовсе, заменив вторую $2$ на $0$.

Создайте файл с содержимым вида:

\begin{lstlisting}
<div>
<div />
</div>
\end{lstlisting}

И вы получите ошибку:

$$
\textbf{Expected indentation of 2 space characters but found 0 (react/jsx-indent)}
$$

Аналогичным образом мы можем заставить всех использовать одинаковый отступ для всех параметров элементов:

\begin{lstlisting}
"react/jsx-indent-props": [2, 2]
\end{lstlisting}

Также часто возникают вопросы, на которые у каждого разработчика может найтись свое мнение отличное от других. Например, какой максимальной длины должны быть строки кода? Или когда считать, что у элемента слишком много параметров? С ESLint и правилом jsx-max-props-per-line можно выбрать единое значение для всех, чтобы не возвращаться к этому вопросу на каждом ревью кода.

React плагин для ESLint позволяет проверять не только JSX, но и сами компоненты. 

Например, мы можем договориться определять PropTypes в алфавитном порядке. Есть правило, чтобы проверить, что используются только объявленные в PropTypes параметры. Или правило для проверки того, что все компоненты без состояния объявлены в функциональном стиле. А также множество других правил.

\subsection{Airbnb configuration}

Мы уже посмотрели, как ESLint помогает искать ошибки и следовать единому стилю кода. Также мы увидели, насколько ESLint открыт для настройки и расширения.

Можно сделать шаг дальше.

Через атрибут extends в файле настроек ESLint можно подключить конфигурации сторонних организаций, а затем уже добавлять свои правила поверх них.

Одна из самых известных конфигураций для ESLint в мире React была создана в стенах компании Airbnb. Разработчики этой компании создали набор правил, чтобы следовать единому стилю кода среди всех разработчиков, и каждый желающий может подключить этот набор правил в свой проект.

Для того, чтобы сделать это, необходимо добавить несколько зависимостей:

\begin{lstlisting}
npm install --global eslint-config-airbnbeslint@^2.9.0 eslint-plugin-jsx-a11y@^1.2.0 eslint-plugin-import@^1.7.0 eslint-plugin-react@^5.0.1
\end{lstlisting}

А затем добавить новые настройки в .eslintrc:

\begin{lstlisting}
{
  "extends": "airbnb"
}
\end{lstlisting}

Это один из самых простых и распространенных способов начать работать с ESLint.


\section{Основы функционального программирования}

Кроме исправления JSX и использования линтера есть еще один способ сделать код чище: следовать \textbf{Функциональному (Functional Programming, FP)} стилю.

Функциональное программирование -- парадигма декларативного программирования, сосредоточенная на минимизации побочных эффектов (side effects) и сохранении данных неизменяемыми (immutable).

Следующая часть не ставит своей целью полностью раскрыть обширную тему функционального программирования, но мы можем посмотреть на некоторые концепции, которые часто используются в React. 

\subsection{Объект первого класса}

В JavaScript функции являются \textit{объектами первого класса (first-class objects)}, т.е. они могут быть присвоены переменным как значение и переданы как аргументы другим функциям.

Это позволяет нам ввести концепцию \textbf{Функций высшего порядка (Higher-order Functions, HoF)}. Такой функцией мы будем назвать функцию, которая принимает аргументом функцию (и возможно другие аргументы) и возвращает новую функцию. Возвращаемая функция чаще всего расширяет функционал изначальной функции.

Посмотрим на простой пример, функцию сложения двух чисел, которую мы обернем функцией, логирующей все аргументы функции и вызывающей изначальную функцию сложения:

\begin{lstlisting}
const add = (x, y) => x + y

const log = func => (...args) => {
  console.log(...args)
  return func(...args)
}
const logAdd = log(add)
\end{lstlisting}

Функции высшего порядка часто используется в React разработке. Один из самых распространенных паттернов использования этого приема - \textbf{Компоненты высшего порядка (Higher-order Components, HoC)}. Подробнее на компоненты высшего порядка мы посмотрим в Главе 4.

\subsection{Purity}

Важный аспект функционального программирования -- чистые функции. С ними вы будете встречаться очень часто, особенно в таких библиотеках как Redux.

Главное отличие чистой функции -- отсутствие побочных эффектов.

К примеру, если функция меняет состояние приложения, меняет значение переменных во внешней области видимости переменных или меняет значение переменных переданных по ссылке, то функция не является чистой.

Чистые функции значительно проще тестировать так как при вызовах с одинаковыми аргументами функция возвращает одинаковый результат.

Простой пример чистой функции -- функция сложения:

\begin{lstlisting}
const add = (x, y) => x + y 
\end{lstlisting}

Она может быть запущена множество раз с одними и теми же аргументами, но в каждый раз она вернет одинаковый результат. 

В следующем примере функция перестает быть чистой:

\begin{lstlisting}
let x = 0
const add = y => (x = x + y)
\end{lstlisting}

Если мы вызовем $add(1)$ дважды, то сначала мы получим $1$, а затем $2$. Причина в том, что работа функции зависит от переменной во внешней области видимости, которая еще и редактируется внутри этой функции.

\subsection{Immutability}

Мы разобрались с чистыми функциями, которые не изменяют состояние приложения. Но что если в функцию приходит сложный объект, в котором мы хотим что-либо изменить? 

FP говорит нам о том, что в этом случае следует создать новый объект с измененным значением и вернуть его, не трогая исходный объект.

Рассмотрим пример:

\begin{lstlisting}
const add3 = arr => arr.push(3)
const myArr = [1, 2]
add3(myArr) // [1, 2, 3]
add3(myArr) // [1, 2, 3, 3]
\end{lstlisting}

Эта функция изменяет состояние исходного массива, что противоречит парадигме неизменяемости. Если вызвать эту функцию несколько раз с одним и тем же исходными массивом, то мы будем получать разные значения на выходе.

Мы можем исправить эту функцию, чтобы она стала immutable с помощью метода concat, который возвращает новый массив, оставляя исходный без изменений:

\begin{lstlisting}
const add3 = arr => arr.concat(3)
const myArr = [1, 2]
const result1 = add3(myArr) // [1, 2, 3]
const result2 = add3(myArr) // [1, 2, 3]
\end{lstlisting}

Или используя спред оператор:

\begin{lstlisting}
const add3 = arr => [...arr, 3]
\end{lstlisting}

Сколько бы мы ни вызывали этот метод, исходный массив остается нетронутым. 

\subsection{Каррирование}

\textbf{Каррирование (Curring)} -- еще одна распространенная техника функционального программирования. В этом случае функция от многих переменных конвертируется в функцию одной переменной, которая возвращает другую функцию.

Посмотрим на примере функции $add$ как это работает на практике. Вместо исходной функции от двух аргументов:

\begin{lstlisting}
const add = (x, y) => x + y
\end{lstlisting}

Мы можем определить каррированную функцию:

\begin{lstlisting}
const add = x => y => x + y
\end{lstlisting}

Такую функцию мы можем использовать следующим образом:

\begin{lstlisting}
const add1 = add(1)
add1(2) // 3
add1(3) // 4
\end{lstlisting}

Таким способом мы можем заключить первый аргумент внутри переменной $add1$ и использовать ее множество раз без явной передачи.

\subsection{Композиция}

Композиция (Composition) - еще один прием, который позволяет сохранять функции небольшими и тестируемыми.

Рассмотрим следующий пример:

\begin{lstlisting}
const add = (x, y) => x + y
const square = x => x * x
\end{lstlisting}

Эти функции могут быть скомбинированы вместе, чтобы создать новую функцию, которая складывает два числа и возвращает их квадрат:

\begin{lstlisting}
const addAndSquare = (x, y) => square(add(x, y))
\end{lstlisting}

Следуя этому простому приему можно сохранять функции небольшими и читаемыми, а также упростить их тестирование.



\subsection{FP и пользовательские интерфейсы}

Последний шаг -- понять, как функциональное программирование помогает нам строить пользовательский интерфейс. 

Мы можем думать о UI как о функции, которая принимает аргументом состояние приложения, а возвращает интерфейс приложения:

$$
UI = f(state)
$$

Мы хотим ожидать, что эта функция будет чистой, т.е. для одного и того же состояния приложения она будет возвращать всегда одинаковое представление для пользователя.

В React мы будем рассматривать компоненты как функции и комбинировать из этих функций пользовательский интерфейс.

Есть много схожего между функциональным программирование и созданием пользовательского интерфейса с React. И чем больше мы будем смотреть на разработку с React как на функциональное программирование, тем лучше будет наш код.

\section{Заключение}

В этой главе мы детально разобрали строение JSX, и как с помощью него создавать компоненты.

Также мы разобрались со статической проверкой кода средствами ESLint и его плагинов. Это позволит нам быстрее находить потенциальные проблемы в коде.

И в конце мы рассмотрели базовые концепции функционального программирования, которые часто встречаются в React. 

Используя все выше сказанное, можно сделать код значительно чище и более тестируемым. Настало время сделать еще один шаг вперед и разобраться, как сделать действительно переиспользуемые компоненты.
