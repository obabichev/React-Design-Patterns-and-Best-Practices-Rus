\chapter{Отрисовка приложения на стороне сервера}

Следующий шаг на пути изучения React -- отрисовка на стороне сервера. \textbf{Изоморфные приложения (Universal applications)} хорошо в SEO (Search Engine Optimisations), а также позволяют обмениваться знаниями между фронтендом и бекендом. 

Такие приложения могут уменьшить время между началом загрузки страницы и моментом, когда пользователь начинает воспринимать информацию на ней. Однако отрисовка на стороне сервера React приложений влечет за собой дополнительные расходы, поэтому мы должны понимать, когда нам действительно это необходимо.

В этой главе мы посмотрим, как настроить отрисовку на стороне сервера, а также разберемся в плюсах и минусах этого подхода.

В этой главе мы рассмотрим следующие вопросы:

\begin{itemize}
	\item Что такое Изоморфное приложение 
	\item Причины, по которым мы можем захотеть включить отрисовку на стороне сервера
	\item Создание простого React приложения с отрисовкой на стороне сервера
	\item Загрузка данных при отрисовке на стороне сервера и концепция dehydration/hydration
	\item Использование \textbf{Next.js} от Zeith для создания React приложения, которое будет запускаться и на сервере и на клиенте
\end{itemize}

\section{Универсальные приложения}

Когда мы говорим о JavaScript web приложениях, мы обычно думаем о коде, который выполняется в браузере пользователя.

Основной подход работы с SPA приложениями, это передача на клиент почти пустого HTML с тегом script, в котором будет загружен код приложения. Затем этот код уже напрямую взаимодействует с DOM в браузере для отображения UI пользователю. Таким образом приложения работали последние несколько лет, таким же образом множество из них продолжают работать сейчас. 

В этой книге мы уже рассмотрели, как создавать приложения с помощью React компонент и как они работают в браузере. Но чего мы еще не касались, как React может создавать те же самые компоненты на стороне сервера, что называется \textbf{Отрисовкой на стороне сервера (Server-Side Rendering, SSR)}.

Перед тем, как мы углубимся в детали, давайте поймем, что же это в принципе означает, что приложение может отрисовываться и на сервере и на клиенте. Многие годы мы были вынуждены создавать отдельные приложения для сервера и клиента: например, Django приложение для отрисовки на сервере, и JavaScript фреймворки, такие, как Backbone или jQuery, для отрисовки на клиенте. 

В таком подходе требуется две команды разработчиков с различными наборами навыков. Если вам требовалось передавать данные между страницей, созданной на сервере, и JavaScript приложением, то вы могли вставлять специальные переменные в тэг $script$. При использовании двух различных языков программирования не было возможности делиться общей информацией, такой как модели или отображения, между различными частями приложения.

С момента релиза Node.js в 2009 было приложено немало усилий на укрепление позиций JavaScript в бекенд разработке, где немалую роль сыграли фреймоврки для создания web приложений, такие как, например, \textbf{Express}.

Использование одного и того же языка с обеих сторон позволяет не только упростить для разработчиков переиспользование их знаний, но также открывает различные пути обмена кодом между клиентом и сервером.

В частности, с React концепция изоморфных приложений стала очень популярной в JavaScript сообществе.

Создание \textbf{изоморфного приложения} означает разработку приложения, которые будет выглядеть одинаково и на сервере и на клиенте.

Использование одного языка программирования открывает новые возможности для переиспользования логики. Также упрощается анализ кода, и уменьшается количество дублирующегося кода.

React делает еще один шаг вперед, предоставляя удобное API для отрисовки компонент на сервере, а также сам выполняет все необходимые действия, чтобы сделать страницу интерактивной (например, обработчики событий) в браузере.

Термин изоморфный не очень хорошо подходит в данном случае, потому что в случае с React приложения именно одинаковые. По этой причине один из создателей React Router, \textit{Майкл Джексон (Michael Jackson)}, предложил более значимое название для этого паттерна: \textit{Универсальный (Universal)}

Универсальным приложением мы будем называть приложение, которое использует одинаковый код для запуска и на сервере и на клиенте.

В этой главе мы поговорим о том, почему мы должны рассматривать создание Универсальных приложений, и как React помогает отрисовывать компоненты на стороне сервера.


\section{Мотивация к отрисовке на стороне сервера}

\textbf{SSR} -- отличный инструмент, но не стоит использовать его только для того, чтобы использовать его, необходимо понимать, как этот инструмент может улучшить наше приложение и какие проблемы решить.

\subsection{SEO}

Одна из главных причин для отрисовки приложения на стороне сервера -- \textbf{Поисковая оптимизация (Search Engine Optimization, SEO)}.

Проблема в том, что когда мы отдаем поисковому роботу (crawler) поисковой машины пустую HTML страницу, он не может вытащить из нее значимую информацию. 

На данный момент Google уже должен уметь запускать JavaScript при сканировании страниц, но все равно есть множество ограничений, а SEO является критическим фактором для множества бизнесов.

Последние годы мы были вынуждены писать два приложения: одно для поисковых роботов, которое отрисовывалось на сервере, а второе для пользователя.

Нам приходилось делать это, так как приложения, создаваемые на сервере не обладали достаточной интерактивностью, ожидаемой пользователями, а приложения, запускаемые в браузере, не индексировались поисковыми машинами.

Поддержка двух приложений вместо одного доставляет хлопот и делает код менее гибким и открытым к изменениям.

К счастью, с React мы можем отрисовывать приложения на стороне сервера и отдавать их поисковым роботам в удобном для индексации виде.

Также это влияет на отображение ссылок на наши страницы в социальных сетях, где, как правило показывается превью страниц, которыми делятся пользователи.

Например, с помощью Open Graph мы можем сказать Facebook, что для определенной страницы должны быть показаны определенные изображение и заголовок.

Но сделать это без SSR невозможно, так как поисковые машины извлекают информацию из страниц, полученных от сервера. А если наш сервер присылает по всем URL пустую страницу, то и превью всех наших страниц будет пустым.


\subsection{Общая кодовая база}

У нас не много вариантов при разработке web приложений: мы можем использовать JavaScript, или вместо него можем использовать JavaScript. Конечно, есть языки программирования, которые компилируются в JavaScript, но принципиально картину это не меняет.

Возможность использования такого же языка программирования на сервере открывает новые возможности поддержки приложений и обмена знаниями внутри компании. 

Реализация общей логики для клиента и сервера на одном языке программирования упрощает внесение изменений в эту логику, так как не придется реализовывать их дважды разными командами, что ведет к уменьшению количества ошибок в коде. 

Усилия, которые необходимо затратить для поддержки одного проекта, будут значительно меньше усилий по актуализации двух различных приложений.

Возможность использования одного языка упрощает сотрудничество между командами, так как они находятся в одном информационном пространстве, что ускоряет принятие решений и внесение изменений.

\subsection{Повышение производительности}

Мы любим SPA приложения за то, что они быстры и отзывчивы, но есть одна проблема: перед тем как пользователь сможет сделать что-либо на сайте должен быть загружен и запущен бандл с приложением.

Это может не быть проблемой для пользователей с быстрым интернет соединением, но для пользователей с 3G соединением время ожидания станет ощутимым. В целом это не проблема UX, но это также влияет на конверсию. Крупными e-commerce сайтами было доказано, что изменение времени загрузки в большую или меньшую сторону даже на несколько миллисекунд может значительно влиять на прибыль.

Например, если мы отдаем с сервера пустую HTML страницу с тегом $script$, которая показывает индикатор загрузки до момента, когда пользователь сможет полноценно взаимодействовать с сайтом, то восприятие производительности сайта пользователем будет искажено не в лучшую для нас сторону.

Если же мы отрисовываем приложение на стороне сервера, и пользователь видит часть контента сразу после загрузки страницы, то он с большой вероятностью останется на странице, даже если для полноценной работы ему придется ждать столько же времени, так как загрузку бандла с приложением никто не отменял.

Таким образом мы можем значительно улучшить восприятие пользователем производительности сайта за счет того, что будем часть контента отдавать вместе со страницей.

\subsection{Не все так просто}

Очевидно, что даже с удобным API для создания Универсальных приложений, создание таких приложений будет требовать дополнительных усилий. Таким образом, перед тем, как включать отображение на сервере, нужно убедиться, что у нас есть причины для этого, а наша команда готова это сделать.

Как мы увидим дальше, отрисовка React компонент -- не единственная проблема, которую нужно решить для полноценной отрисовки на стороне сервера.

Нас ожидает настройка и поддержка сервера с навигацией, управление потоком данных, кеширование контента, чтобы быстрее отдавать данные, и множество других интересных задач на пути создания полноценного Универсального приложения.

По этим причинам я советую начинать с приложения, которое полностью работоспособно без поддержки сервера, а затем оценивать плюсы и минусы перехода на SSR.

Включать отрисовку на стороне сервера стоит при жесткой необходимости в этом. Например, если вам нужна оптимизация для поисковых машин или кастомизация отображения для социальных сетей.

Если вы осознали, что ваше приложение загружается слишком долго, а все оптимизации (подробнее об оптимизациях мы поговорим в следующей главе) уже применены, вы можете решить использовать SSR для уменьшения времени между началом загрузки страницы и первого взаимодействия пользователя с контентом. 

\textit{Кристофер Пожер(Christopher Pojer)}, инженер Facebook, сказал в Twitter, что в приложении Instagram они используют SSR только в целях SEO. Он сказал, что для приложений с динамическим контентом, как например Instagram, использовать SSR в целях улучшения восприятия пользователя не эффективно:

$$
\href{https://twitter.com/cpojer/status/711729444323332096}{https://twitter.com/cpojer/status/711729444323332096}
$$

\section{Простой пример}

Пришло время создать простое приложение с отрисовкой на стороне сервера и посмотреть, какие шаги нужно выполнить для создания Универсального приложения.

Мы создадим минимальное и простое приложение, так как наша цель -- посмотреть, как работает SSR, а не предоставить комплексное решение или шаблон для проекта.

В данном разделе мы предполагаем, что вы знакомы с концепциями сборки JavaScript приложения и такими инструментами как Webpack. Также будет полезен опыт работы с Node.js, но даже без него, со знанием JavaScript, вы сможете разобраться в этой главе.

Приложение будет состоять из двух частей:

\begin{itemize}
	\item Серверное $Express$ приложение, которое будет отдавать HTML страницу с отрисованным React приложением
	\item Клиентскую часть, где мы будем отображать приложение привычным для нас образом с помощью $react-dom$.
\end{itemize}

Обе части приложения пройдут через Babel и Webpack, поэтому мы можем спокойно использовать все возможности ES2015 и на клиенте и на сервере.

Начнем с того, что создадим пустую директорию и инициализируем в ней npm проект:

\begin{lstlisting}
	npm init
\end{lstlisting}

После того, как будет создан package.json, мы можем начать устанавливать зависимости. Начнем с Webpack:

\begin{lstlisting}
	npm install --save-dev webpack
\end{lstlisting}

Также нам понадобится Babel и пресеты для ES2015 и JSX:

\begin{lstlisting}
	npm install  --save-dev babel-loader babel-core babel-preset-es2015 babel-preset-react
\end{lstlisting}

Также нам нужно добавить пакеты для сборки серверного бандла. 
Webpack позволяет определить список зависимостей, которые необходимо исключить из сборки бандла. Например, при сборке серверного приложения мы не хотим добавлять весь код проекта, а только релевантную для сервера часть. Есть пакет, который упрощает этот процесс:

\begin{lstlisting}
	npm install --save-dev webpack-node-externals
\end{lstlisting}

Не забудем добавить в $package.json$ скрипт для удобного запуска webpack из терминала:

\begin{lstlisting}
"scripts": {
  "build": "webpack"
},
\end{lstlisting}

Теперь нам понадобится файл конфигурации Webpack $webpack.config.js$ для управления сборкой приложения.

Начнем с импорта библиотеки для определения исключаемых файлов. Также добавим настройки для Babel загрузчика, который мы будем использовать его и на клиенте и на сервере:

\begin{lstlisting}
const nodeExternals = require('webpack-node-externals')

const loaders = [{
  test: /\.js$/,
  exclude: /(node_modules|bower_components)/,
  loader: 'babel',
  query: {
    presets: ['es2015', 'react'],
  },
}]
\end{lstlisting}

В \textit{Главе 7} мы уже видели, как в файле конфигурации создается объект конфигурации. Но помимо этого Webpack позволяет определять множество разных конфигураций внутри одного файла, что мы и сделаем для клиентского и серверного приложений.

Конфигурация клиентского приложения будет выглядеть уже знакомой:

\begin{lstlisting}
const client = {
  entry: './src/client.js',
  
  output: {
    path: './dist/public',
    filename: 'bundle.js',
  },
  
  module: { loaders },
}
\end{lstlisting}

Мы говорим Webpack, что исходный код приложения находится в папке $src$, а бандл приложения должен создаваться в папке $dist$.

Также мы установили список загрузчиков, созданный ранее при помощи $babel-loader$. Выглядит простым настолько, насколько это возможно.

Серверная конфигурация будет несколько отличаться, но не должны вызвать проблем для понимания:

\begin{lstlisting}
const server = {
  entry: './src/server.js',
  
  output: {
    path: './dist',
    filename: 'server.js',
  },
  
  module: { loaders },
  
  target: 'node',
  
  externals: [nodeExternals()],
}
\end{lstlisting}

Как вы можете видеть, структура та же, за исключением $externals$ и $target$, но с другими путями к файлам.

С помощью параметра $target$ со значением $node$ мы говорим Webpack, что нужно игнорировать все встроенные в node пакеты, такие как $fs$. Через $externals$ мы используем библиотеку для исключения зависимостей из сборки.

И в конце мы экспортируем конфигурации в виде массива:

\begin{lstlisting}
module.exports = [client, server]
\end{lstlisting}

Конфигурация завершена. Теперь мы можем начать писать код и начнем с React приложения, с которыми мы на данный момент работали больше.

Создадим папку $src$ и файл $app.js$ внутри него.

В файл $app.js$ добавим следующее содержимое:

\begin{lstlisting}
import React from 'react'

const App = () => <div>Hello React</div> 

export default App
\end{lstlisting}

Здесь никакой магии: импортируем React, создаем компонент App и экспортируем его.

Теперь создадим файл $client.js$, который будет непосредственно отрисовывать компонент $App$ в DOM браузера:

\begin{lstlisting}
import React from 'react'
import ReactDOM from 'react-dom'
import App from './app'

ReactDOM.render(<App />, document.getElementById('app'))
\end{lstlisting}

Этот код должен выглядеть знакомо. Мы импортируем React, ReactDom и созданный ранее компонент App, а затем просим ReactDom отрисовать этот компонент в элемент DOM с id $app$.

Теперь двинемся в сторону сервера.

Для начала создадим файл $template.js$ с функцией для создания разметки страницы, которая будет отправляться пользователю:

\begin{lstlisting}
export default body => `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
  </head>
  <body>
    <div id="app">${body}</div>
    <script src="/bundle.js"></script>
  </body>
</html> `
\end{lstlisting}

Здесь создается функция, которая принимает React приложение через параметр $body$ и возвращает скелет страницы.

Отметим, что мы все равно должны загружать бандл с приложением на клиент, так как отрисовка на стороне сервера создает лишь каркас страницы, а все взаимодействие с пользователем, такое как обработка событий ввода, происходить все равно на клиенте.

Пришло время для создания файла $server.js$, в котором будет больше зависимостей:

\begin{lstlisting}
import express from 'express'
import React from 'react'
import ReactDOM from 'react-dom/server'
import App from './app'
import template from './template'
\end{lstlisting}

Первая зависимость -- библиотека $express$, которая позволяет легко создать web сервер с маршрутизацией и выдачей статических файлов.

Затем мы импортируем React и ReactDom для отрисовки нашего приложения $App$, которое мы также импортируем. Заметьте, что мы импортируем ReactDom из $react-dom/server$. И в конце мы импортируем наш шаблон страницы, созданный ранее.

Теперь создадим сервер Express приложения:

\begin{lstlisting}
const app = express()
\end{lstlisting}

А также скажем серверу, где находятся статические файлы:

\begin{lstlisting}
app.use(express.static('dist/public'))
\end{lstlisting}

Вы можете заметить, что мы используем тот же путь, который использовали в настройках Webpack клиентского приложения для сохранения бандла. 

Теперь напишем саму логику отрисовки приложения на стороне сервера с помощью React:


\begin{lstlisting}
app.get('/', (req, res) => {
  const body = ReactDOM.renderToString(<App />)
  const html = template(body)
  res.send(html)
})
\end{lstlisting}

Мы говорим Express, что хотим прослушивать путь $/$, и когда пользователь перейдет по нему, мы отрисуем компонент $App$ в строку с помощью библиотеки ReactDOM. Здесь собственно и происходит магия серверной отрисовки React приложения.

Функция $renderToString$ возвращает строковое представление DOM элементов созданного компонента App, идентичное тому, которое было бы создано на клиенте методом $render$.

Значение переменной $body$ будет выглядеть примерно следующим образом:

\begin{lstlisting}
<div data-reactroot="" data-reactid="1" data-react-checksum="982061917">Hello React</div>
\end{lstlisting}

Теперь мы можем передать это строковое представление компонента функции $template$, чтобы создать HTML страницу с уже отрисованными компонентами и вернуть ее пользователю.

И осталось только запустить приложение на нужном нам порту:

\begin{lstlisting}
app.listen(3000, () => {
  console.log('Listening on port 3000')
})
\end{lstlisting}

Почти готово, осталось добавить скрипт в package.json, чтобы было удобнее запускать:

\begin{lstlisting}
"scripts": {
  "build": "webpack",
  "start": "node ./dist/server"
},
\end{lstlisting}

Теперь мы можем собрать бандл командой $build$:

\begin{lstlisting}
	npm run build
\end{lstlisting}

И запустить сервер командой $start$:

\begin{lstlisting}
	npm start
\end{lstlisting}

Теперь можно открыть в браузере страницу http://localhost:3000 и увидеть результат.	

Отметим, что если вы откроете Исходный код страницы (View Page Source), то увидите, что она была получена от сервера с уже отрисованным приложением, чего не произошло бы с отключенным SSR.

Также, если у вас установлено React расширение для браузера, вы сможете увидеть, что приложение было загружено на клиенте.

\section{Пример загрузки данных}

После предыдущей части вы должны понимать, как настроить работу Универсального приложения в React. В целом, это задача не требует принципиально новых знаний, и большая часть проблем, с которыми вы скорее всего встретились, относится к настройке самого проекта.

Но в большинстве реальных проектов вам будет недостаточно создания статичной разметки. Предположим, что мы хотим загрузить все гисты \textit{Дена Абрамова} и вернуть их из созданного Express приложения пользователю.

Ранее, в Главе, 5 мы уже разбирались, как загрузить данные с помощью метода $componentDidMount$ жизненного цикла. Но этот метод не будет работать на сервере, так как компонент не монтируется к DOM и методы жизненного цикла не срабатывают.

Помимо этого обычные способы загрузки данных через методы жизненного цикла компонентов не будут работать, так как они \textbf{асинхронные}, а метод $renderToString$ -- нет. Поэтому нам придется каким-либо образом грузить данные предварительно и передавать компонентам через параметры.

Давайте возьмем приложение из предыдущей части и посмотрим, как мы можем его поправить, чтобы гисты загружались во время отрисовки приложения на сервере.

Первое, что нам нужно будет сделать, это поправить $app.js$, чтобы была возможность передать через параметры гисты для отрисовки их описаний:

\begin{lstlisting}
const App = ({ gists }) => (
  <ul>
    {gists.map(gist => (
      <li key={gist.id}>{gist.description}</li>
    ))} 
  </ul>
)

App.propTypes = {
  gists: React.PropTypes.array,
}
\end{lstlisting}

С применением уже изученных подходов мы создаем функциональный компонент, который получает параметр $gists$, обходит его в цикле и отрисовывает список элементов.

Теперь нам нужно поправить сервер, чтобы иметь возможность загружать список гистов и передавать его компоненту.

Для использования \textbf{fetch} на сервере, мы добавим библиотеку $isomorphic-fetch$, которая реализует такую возможность. Эта библиотека может быть использована и с node и в браузере:

\begin{lstlisting}
	npm install --save isomorphic-fetch
\end{lstlisting}

Сначала импортируем эту библиотеку в $server.js$:

\begin{lstlisting}
import fetch from 'isomorphic-fetch'	
\end{lstlisting}

Вызов сетевого API, которое мы собираемся использовать, будет выглядеть следующим образом:

\begin{lstlisting}
fetch('https://api.github.com/users/gaearon/gists')
  .then(response => response.json())
  .then(gists => {
  
  })
\end{lstlisting}


После выполнения этой функции, требуемые нам гисты будут доступны в переменной $gists$ последней переданной функции. Теперь нам нужно передать их компоненту $App$.

Для этого поправим обработку сетевого пути $/$ следующим образом:

\begin{lstlisting}
app.get('/', (req, res) => {
  fetch('https://api.github.com/users/gaearon/gists')
    .then(response => response.json())
    .then(gists => {
      const body = ReactDOM.renderToString(<App gists={gists} />)
      const html = template(body)
      res.send(html)
    })
})
\end{lstlisting}

Собственно теперь мы сначала загружаем список гистов, а затем передаем их компоненту $App$.

После того, как компонент $App$ будет отрисован, и мы получим его разметку, мы можем воспользоваться шаблоном из предыдущей части, чтобы вернуть полную страницу пользователю.

Запустим приложение следующей командой и откроем страницу \href{http://localhost:3000}{http://localhost:3000} в браузере, где вы будете должны увидеть список гистов, пришедший с сервера:

\begin{lstlisting}
	npm run build && npm start
\end{lstlisting}

Чтобы убедиться, что гисты были отрисованы на сервере, вы можете проверить исходный код страницы:

$$
\href{view-source:http://localhost:3000/}{view-source:http://localhost:3000/}
$$

Там вы увидите разметку и описание гистов.

Все выглядит просто и вроде даже работает, но если мы откроем DevTools, то увидим следующую ошибку:


\begin{quotation}
Cannot read property 'map' of undefined	
\end{quotation}

Проблема в том, что в браузере приложение перерисовывается снова, но получить список гистов ему уже неоткуда.

На первый взгляд это может выглядеть контринтуитивно, так как мы ожидаем, что внутри React достаточно мозгов для использования уже отрисованных гистов. Но все работает немного не так, поэтому нам нужно сделать доступным список гистов также и на клиентской стороне.

Вы можете подумать, что в этом случае достаточно сделать запрос к данным еще раз из браузера. Это безусловно будет работать, но в этом случае HTTP запрос будет выполнен дважды (один раз с сервера, второй раз из браузера), чего хотелось бы избежать. 

Мы уже сделали запрос к данным один раз с сервера, поэтому у нас на руках есть все данные, которые нам нужны. Типичным для такого случая решением может быть сохранение сериализованных данных на странице HTML и их десериализация в браузере.

Может звучать запутанно, но на практике все очень просто. Давайте посмотрим на пример.

Прежде всего нам потребуется поправить шаблон страницы, чтобы сохранить в нем JSON с данными гистов:

\begin{lstlisting}
export default (body, gists) => `
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
    </head>
    <body>
      <div id="app">${body}</div>
      <script>window.gists = ${JSON.stringify(gists)}</script>
      <script src="/bundle.js"></script>
    </body>
  </html>
`
\end{lstlisting}

Теперь шаблон принимает два параметра: $body$ с разметкой компонента $App$ как прежде и $gists$ с загруженными данными. Последний сохраняется в глобальную переменную для дальнейшего использования на клиенте.

Также нужно не забыть поправить использование этого шаблона, чтобы список гистов действительно передавался в него:

\begin{lstlisting}
const html = template(body, gists)
\end{lstlisting}

И в конце нам нужно забрать данные из глобальной переменной $gists$ на клиенте и передать их компоненту $App$, для чего надо будет поправить файл $client.js$ (прим.пер. скорее всего здесь ошибка в коде и должен быть использован JSON.parse на window.gists):

\begin{lstlisting}
ReactDOM.render(
  <App gists={window.gists} />,
  document.getElementById('app')
)
\end{lstlisting}

Таким образом, мы берем данные напрямую из глобального объекта и передаем их компоненту $App$, который перерисуется с ними уже на клиенте.

И снова запустим сервер:

\begin{lstlisting}
	npm run build && npm start
\end{lstlisting}

Теперь при открытии страницы \href{http://localhost:3000}{http://localhost:3000}, ошибка появляться не будет. А также мы можем проверить через DevTool, что компонент $App$ получает данные гистов через $props$.

\section{Next.js}

Мы разобрались с основами отрисовки React приложений на стороне сервера, а также создали небольшой проект, который можно брать за основу для создания других приложений.

Однако, вы можете подумать, что для создания простого Универсального приложения требуется написать слишком много шаблонного кода и разобраться в множестве инструментов.

Знайте, вы не первый, кто испытывает подобные ощущения, которые часто называют \textbf{Усталостью от JavaScript (JavaScript Fatigue)}, о чем сказано во вступлении к этой книге.

К счастью разработчики Facebook и другие компании в сообществе React работают над улучшением DX (Developers Experience) и упрощением жизни разработчиков. Скорее всего вы уже использовали $create-react-app$ для создания приложений, и понимаете насколько оно упрощает создание и запуск приложения. 

На данный момент $create-react-app$ не поддерживает SSR, но есть компания \textit{Zeit}, которая разработала инструмент \textbf{Next.js}. Его использование значительно упрощает создание Универсальных приложений, помогает избежать медитаций над файлами конфигураций, а также уменьшает количество шаблонного кода.

Важно понимать, что использование правильных абстракций, может значительно ускорить процесс создания приложений. Но важно понимать, как все работает изнутри, прежде чем добавлять еще прослойки из инструментов. Именно поэтому мы сначала разбирались, как сделать все вручную, перед изучением Next.js.

Мы уже посмотрели, как работает SSR и как передать состояние приложения от сервера клиенту. Теперь, зная основные концепции SSR, мы можем добавить инструмент, который скроет от нас часть этого процесса и позволит писать меньше кода для достижения того же результата.

Мы создадим аналогичное приложение, в котором будут загружаться гисты Дена Абрамова, но сделаем это с помощью Next.js.

Начнем с того, что откроем пустую папку и создадим в ней проект:

\begin{lstlisting}
	npm init
\end{lstlisting}

После этого мы можем установить саму библиотеку:

\begin{lstlisting}
	npm install --save next
\end{lstlisting}

Теперь добавим в package.json скрипт для запуска этой библиотеки:

\begin{lstlisting}
"scripts": {
  "dev": "next"
},
\end{lstlisting}

Великолепно, теперь мы можем перейти к созданию компонента $App$.

\textbf{Next.js} основан на некоторых договоренностях, одна из самых важных заключается в том, что вы можете создавать страницы, которые будут соответствовать разным URL. Страница по умолчанию -- index, поэтому мы можем создать директорию $pages$ и файл $index.js$ внутри нее.

Добавим в этот файл следующие зависимости:

\begin{lstlisting}
import React from 'react'
import fetch from 'isomorphic-fetch'
\end{lstlisting}

Мы также будем использовать $isomorphic-fetch$, так как хотим использовать функцию $fetch$ на сервере.

Теперь создадим класс для нашего приложения, который будет наследовать $React.Component$:

\begin{lstlisting}
class App extends React.Component
\end{lstlisting}

В этом классе мы создадим \textbf{static async} функцию $getInitialProps$, в которой мы сможем сказать Next.js, какие данные мы хотим загружать и на клиенте и на сервере. Библиотека сделает объект, возвращенный из этой функции, доступным внутри компонента.

Ключевые слова $static$ и $async$ говорят о том, что метод можно будет использовать непосредственно из класса, а не через его экземпляры, и о том, что внутри функции используются асинхронные операции.

Разбор этих концепций выходит за рамки книги, но если они вас заинтересовали, вы всегда можете взглянуть на ECMAScript proposals.

Реализацию данного метода будет выглядеть следующим образом:

\begin{lstlisting}
static async getInitialProps() {
  const url = 'https://api.github.com/users/gaearon/gists'
  const response = await fetch(url)
  const gists = await response.json()
  return { gists }
}
\end{lstlisting}

В этой функции мы делаем асинхронный сетевой запрос на загрузку списка гистов. Дожидаемся выполнения этой функции и возвращаем объект с данными.

Метод $render$ компонента остается очень похожим на предыдущий:

\begin{lstlisting}
render() {
  return (
    <ul>
      {this.props.gists.map(gist => (
        <li key={gist.id}>{gist.description}</li>
      ))}
    </ul>
  )
}
\end{lstlisting}

Единственное отличие заключается в строке $this.props.gists$, так как теперь мы используем класс.

И не стоит забывать про $PropTypes$, чтобы интерфейс компонента оставался в актуальном состоянии:

\begin{lstlisting}
App.propTypes = {
  gists: React.PropTypes.array,
}
\end{lstlisting}

Теперь мы можем экспортировать компонент:

\begin{lstlisting}
export default App
\end{lstlisting}

И запустить приложение из консоли:

\begin{lstlisting}
	npm run dev
\end{lstlisting}

Об успешном запуске должно свидетельствовать сообщение:

\begin{quotation}
	> Ready on http://localhost:3000
\end{quotation}

Если мы откроем эту страницу в браузере, то увидим Универсальное приложение в действии.

На этом примере вы можете увидеть, насколько Next.js упрощает создание Универсальных приложений.

Вы также можете заметить, что если вы начнете редактировать код с запущенным сервером, то страница будет автоматически обновляться. Это работает за счет того, что Node.js реализует возможность замены кода на лету (hot module replacement), что очень удобно во время разработки приложения.

Если вам понравился Node.js, никто не запрещает вам добавить им звездочку на GitHub:

\begin{lstlisting}
	https://github.com/zeit/next.js
\end{lstlisting}


\section{Заключение}

Приключение по отрисовке приложения на стороне сервера подошло к концу. Теперь вы должны понимать, как создать Универсальное приложение, и какие плюсы это может принести. SEO -- главная причина для отрисовки приложения в большинстве случаев, но отображение ссылок в социальных сетях и производительность могу также сказать свое веское слово.

Также мы разобрались, как загрузить данные на стороне сервера и передать в браузер через сохранение внутри HTML кода.

И в конце мы посмотрели, как специальные инструменты, такие как Next.js, могут уменьшить сложность кода, которую обычно приносит SSR.

И в следующей главе мы поговорим о производительности React приложений.






