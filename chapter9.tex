\chapter{Улучшаем Производительность Приложений}

Производительность web приложения может в значительной степени влиять на пользовательский опыт и конверсию. React реализует множество подходов, чтобы уменьшить изменение DOM браузера настолько, насколько это возможно. Применение изменений к DOM -- достаточно дорогостоящая операция, поэтому критически важным становится уменьшение их количества.

Однако, есть некоторое множество сценариев, в которых React не может оптимизировать процесс отрисовки компонентов. В таких случаях разработчик вынужден реализовать решение, которое поможет приложению работать плавно.

В этой главе мы разберем базовые концепции производительности React приложений, и посмотрим на API библиотеки React, которые мы можем использовать, чтобы помочь библиотеке оптимально обновлять DOM. Также мы разберем распространенные ошибки, которые приводят к существенному ухудшению производительности приложения.

На простых примерах мы разберем, какие инструменты мы можем добавить в проект, чтобы отслеживать производительность приложения и искать проблемные участки кода. Также мы посмотрим, как неизменяемые (immutable) объекты и \textit{PureComponent} могут помочь в создании быстрого приложения.

В этой главе мы разберем следующие вопросы:

\begin{itemize}
	\item Как работает согласование (reconciliation), и как мы можем использовать ключи (keys) для увеличения эффективности этого процесса
	\item Как использование production версии React меняет его производительность
	\item Как использовать \textit{PureComponent} и метод жизненного цикла \textit{shouldComponentUpdate}
	\item Основные способы оптимизации приложения и ошибки, вызывающие падение производительности
	\item Использование неизменяемых (immutable) данных
	\item Полезные инструменты и библиотеки для улучшения производительности приложения
\end{itemize}

\section{Согласование и ключи}

В большинстве случаев React работает достаточно быстро, чтобы не думать о проблемах производительности приложения. React использует различные техники для оптимизации отрисовки компонентов на экране.

Для отрисовки React вызывает рекурсивно метод \textbf{render} у компонента, затем у его потомков, затем у их потомков и т.д. Вызов метода \textit{render} возвращает дерево элементов, которое React использует для осознания, что нужно изменить в DOM для обновления UI.

Когда состояние компонента меняется, React снова пересоздает дерево элементов с помощью метода \textit{render}, а затем сравнивает полученный результат с предыдущим деревом. React достаточно умен, чтобы понять, какие операции достаточно применить к DOM, чтобы отобразить ожидаемые изменения UI. Этот процесс называется \textbf{согласованием (reconciliation)} и работает под капотом React. Благодаря этому, мы можем описывать в декларативном стиле, как должны выглядеть наши компоненты, пока React делает всю остальную работу по отрисовке.

React пытается делать как можно меньше изменений в DOM, так как внесение изменений в DOM -- относительно дорогостоящая операция.

Однако, сравнение двух деревьев с элементами также не бесплатно, поэтому React делает два допущения, чтобы упростить этот процесс:

\begin{itemize}
	\item Если два элемента обладают разным типом, они отображаются в разные деревья
	\item Разработчик может использовать ключи (keys) для обозначения дочерних элементов стабильными при разных вызовах метода \textit{render}
\end{itemize}  

С точки зрения разработчика второй пункт интереснее, так как предоставляет инструмент для помощи React с оптимизацией отрисовки компонентов.

Сейчас мы посмотрим на простой пример, чтобы понять, как использование ключей может значительно повлиять на производительность приложения.

Давайте создадим простой компонент для отрисовывки списка объектов и кнопки, по нажатию на которую будет добавляться еще один объект в список. После добавления нового элемента в список компонент должен перерисоваться.

Мы создадим компонент с помощью класса, так как нам нужно хранить список объектов для отрисовки, а также создадим обработчик событий для кнопки:

\begin{lstlisting}
class List extends React.Component
\end{lstlisting}

В конструкторе класса \textit{List} добавим создание списка объектов для первой отрисовки, а также привяжем обработчик событий к экземпляру класса:

\begin{lstlisting}
constructor(props) {
  super(props)
  this.state = {
    items: ['foo', 'bar'],
  }

  this.handleClick = this.handleClick.bind(this)
}
\end{lstlisting}

Создадим собственно сам обработчик событий, который будет добавлять новый элемент в список объектов на отрисовку:

\begin{lstlisting}
handleClick() {
  this.setState({
    items: this.state.items.concat('baz'),
  })
}
\end{lstlisting}

И в конце создадим метод \textit{render}, который будет отрисовывать объекты, сохраненные внутри компонента, а также кнопку для добавления новых:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => <li>{item}</li>)}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}	
\end{lstlisting}

Компонент готов, и если вы добавите его в свое приложение (или создадите для этого новое с помощью \textit{create-react-app}), то вы увидите на экране элементы \textbf{foo} и \textbf{bar}, а также кнопку \textit{+}, по нажатию на которую добавиться элемент \textbf{baz}. 

Все работает так, как мы и ожидаем, но для получения полноты картины происходящего внутри React, мы добавим еще один инструмент, который поможет собирать и отображать информацию о производительности приложения. Для его установки можно воспользоваться npm:

\begin{lstlisting}
	npm install --save-dev react-addons-perf
\end{lstlisting}

После установки мы можем импортировать его в файл с компонентом $List$:

\begin{lstlisting}
import Perf from 'react-addons-perf
\end{lstlisting}

У объекта $Perf$ есть несколько полезных методов, которые мы можем использовать для отслеживания производительности React компонентов. С помощью методов $start()$ и $stop()$ мы можем соответственно начать и остановить запись информации о производительности компонента. 

Есть несколько методов для отображения в консоли информации, собранной ранее. $printWasted$ печатает информацию о том, сколько времени было затрачено на вызовы метода $render$, которые не привели к изменению DOM. Также есть метод $Perf$, который позволяет получать информацию о том, какие операции в DOM выполняет React. Этот метод называет $printOperations$, и мы будем использовать его для оценки влияния использования Ключей на производительность приложения. 

Для того, чтобы начинать и останавливать сбор информации о производительности, мы можем методы жизненного цикла $componentWillUpdate$ и $componentDidUpdate$ соответственно, в последнем мы можем также печатать результаты.

Сначала реализуем метод $componentWillUpdate$, который вызывается непосредственно перед обновлением и перерисовкой компонента:

\begin{lstlisting}
componentWillUpdate() {
  Perf.start()
}
\end{lstlisting}

Как и было сказано выше, в этом методе нужно просто начать сбор информации о производительности с помощью метода $start()$. После того, как компонент обновился, мы можем остановить сбор информации и распечатать результаты:

\begin{lstlisting}
componentDidUpdate() {
  Perf.stop()
  Perf.printOperations()
}
\end{lstlisting}

Как вы видите, мы останавливаем измерения и вызываем метод \textit{printOperations}, чтобы увидеть, какие операции сделал React над DOM для добавления элемента \textbf{baz} на экран.

Если мы запустим компонент и нажмем кнопку \textit{+}, то увидим в консоли браузера список совершенных операций в виде таблицы. Нас интересуют столбцы \textit{Operation}, который показывает \textit{"insert child"}, и \textit{Payload}, в котором мы можем увидеть \textit{"\{"toIndex":2,"content":"LI"\}"} 

React распознал, что после добавления новой строки в список необходимо создать новый дочерний элемент \textit{Li}, причем индекс этого элемента должен быть 2 (т.е. третий элемент).

Как вы можете заметить, вместо того, чтобы перерисовывать все компоненты, React высчитал минимально количество операций, которых будет достаточно для обновления DOM. Этот механизм работает прекрасно, и его достаточно для большинства ситуаций, которые могут возникнуть.

Однако есть случаи, когда у React оказывается немного недостаточно мозгов для выбора оптимального набора операций. В некотором множестве таких случаем на помощь может прийти использование Ключей. Если мы немного поправим пример выше и сделаем добавление \textbf{baz} не в конец списка, а в начало, то мы увидим совсем другую картину. 

Для того, чтобы добавить \textbf{baz} в начало списка, мы можем использовать метод \textit{unshift}, но его проблема в том, что он не создает новый массив, а мутирует существующей. Для того, чтобы создать копию массива, мы можем использовать метод \textit{slice} без аргументов (прим.пер. или использовать спред оператор, привет из 2019):

\begin{lstlisting}
handleClick() {
  const items = this.state.items.slice()
  
  items.unshift('baz')
  this.setState({
    items,
  })
}
\end{lstlisting}

Таким образом мы копируем массив, добавляем в его начало строку \textbf{baz} и сохраняем обратно в state, вызывая тем самым перерисовку.

Теперь, когда мы запустим компонент снова, то снова увидим элементы \textbf{foo} и \textbf{bar}, но после нажатия на кнопку \textit{+}, строка \textbf{baz} будет добавлена уже в начало списка.

Все работает так, как мы ожидаем, но если мы снова откроем DevTools, то увидим, что на этот раз React совершил множество операций над DOM, а именно:

\begin{itemize}
  \item Заменил текст первого элемента на \textbf{baz}
  \item Заменил текст первого элемента на \textbf{foo}
  \item Добавил в конец списка новый элемент с текстом \textbf{bar} и индексом 2
\end{itemize}

Таким образом React вместо того, чтобы добавить один новый дочерний элемент в начало списка, изменил оба существующих и добавил новый элемент в конец.

Это происходит из-за того, что React после сравнения первых элементов до и после перерисовки увидел в них разницу и поправил DOM в соответствии с этими изменениями, затем то же самое произошло со вторыми элементами, а в конце React увидел, что в списке появился новый элемент и добавил соответствующий ему элемент.

Конкретно в этом примере это не приводит к видимым потерям производительности, но в реальном приложении могут отображаться списки из сотен элементов, полная перерисовка которых может привести к существенному замедлению приложения.

Но каждая проблемы имеет свое решение, и в данном случае мы можем собственно использовать \textbf{Ключи}, которые помогут React понимать, какие из элементов обновились, добавились или удалились.

Для использования ключей достаточно добавить уникальный атрибут \textit{key} каждому из элементов списка. Важно, чтобы эти ключи не менялись для каждого элемента после перерисовки, так как React будет использовать их для сопоставления элементов до и после перерисовки.

Например, мы можем изменить метод \textit{render} следующим образом:

\begin{lstlisting}
render() {
  return (
    <div> 
      <ul>
        {this.state.items.map(item => <li key={item}>{item}</li>)}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting} 

После того как мы установили значение поля \textit{key} для каждого из элементов в значение этих элементов, мы можем запустить приложение заново. Сразу же мы можем отметить, что функционально поведение компонента не изменилось: есть список из двух элемента и кнопка, по нажатию на которую добавляется новый элемент в начало списка.

Однако, если мы откроем DevTool, то увидим, что теперь снова всего одна операция над DOM, причем это операция добавления дочернего элемента по индексу 0.

Таким образом мы помогли React правильно рассчитать минимальное количество операций, которых будет достаточно для обновления DOM. С помощью этого простого метода мы можем избежать значительных падений производительности при отображении больших списков элементов.

Также отметим, что если мы забудем добавить ключи там, где это требуется, React вежливо напомнит нам об этом:

\begin{quotation}
	\textbf{Each child in an array or iterator should have a unique "key" prop. Check the render method of `List`.}
\end{quotation}

Это сообщение очень удобно, так как говорит о том, какой именно компонент нам необходимо поправить.

Также, если вы используете \textbf{Eslint}, о котором мы говорили в Главе 2, и добавили правило \textit{jsx-key} для \textit{eslint-plugin-react}, то получите аналогичную ошибку на этапе статического анализа кода.


\section{Техники оптимизации}

Важно заметить, что во всех примерах в этой книге мы используем или приложение, созданное с помощью \textit{create-react-app}, или приложение, созданное с нуля, но всегда с версией React для разработки (development version). 

Использование версии React для разработки очень удобно для написания кода и отладки, но нужно понимать, что все проверки и уведомления стоят потерь производительности приложения, которых хотелось бы избежать в финальной сборке приложения.  

Таким образом, первая оптимизация, которую мы должны сделать, это собрать приложение при установленной переменной окружения NODE\_ENV в \textit{production}. 
В случае использования \textbf{Webpack} это всего лишь вопрос использования \textit{DefinePlugin}:


\begin{lstlisting}
new webpack.DefinePlugin({
  'process.env': {
    NODE_ENV: JSON.stringify('production')
  }
}),
\end{lstlisting}

Дальнейшим улучшением нашей сборки может быть минимизация кода, после которой бандл приложения будет меньше весить, а значит быстрее загружаться по сети. Для этого мы можем добавить соответствующий плагин в список плагинов \textbf{Webpack}:

\begin{lstlisting}
new webpack.optimize.UglifyJsPlugin()
\end{lstlisting}

Если какие-либо части приложения все еще выполняются медленно, то мы можем начать применять другие методы оптимизации React приложения.

Важно сказать, что не стоит оптимизировать приложение, пока нет измерений его производительности и понимания, что является узким горлышком. Преждевременная оптимизация приложений, как правило, ведет к излишней сложности последних, чего мы конечно хотели бы избежать. 

Помимо этого, в очередной раз напомним, что React, независимо от нашего кода, уже применяет различные методы оптимизации, так что в большинстве случаев нам вообще не стоит об этом задумываться.

Однако в некоторых случаях, когда из коробки React работает недостаточно быстро, и мы хотим ему помочь, мы можем приказать React остановить процесс согласования для частей дерева элементов.

\subsection{shouldComponentUpdate}

Первое знакомство с процессом согласования в React может стать некоторой болью для многих разработчиков. Интуитивно мы ожидаем, что если с компонентами ничего не происходит, то метод \textit{render} для них не вызывается повторно. К сожалению это далеко от истины.

На самом деле, для того, чтобы правильно оценить все изменения, которые необходимо выполнить в DOM, React вызывает метод \textit{render} для все компонентов, а затем сравнивает результат с предыдущим состоянием дерева элементов.

Если ничего не изменилось, то никаких изменений не будет применено к DOM, но если компоненты сами по себе выполняют тяжелые (с точки зрения вычислений) операции, то они могут замедлять работу всего приложения, даже если изменений в DOM при этом совершаться не будет.

React не может сам оценить, какие компоненты стоит обновлять, а какие нет, но мы можем реализовать специальный метод, чтобы помочь ему в этом вопросе.

Этот метод называется \textit{shouldComponentUpdate}, и если он вернет \textit{false} в процессе обновления дерева, то для него и всех его дочерних элементов метод \textit{render} вызван не будет.


Например, если вы просто добавите следующий код в созданный ранее \textit{List}:

\begin{lstlisting}
shouldComponentUpdate() {
  return false
}
\end{lstlisting}

То при нажатии на кнопку \textit{+} вы не увидите никаких изменений, несмотря на то, что состояние приложения меняется. Это происходит из-за того, что мы явно сказали React, что обновлять компонент не нужно.

Просто возвращать из этого метода \textit{false} с небольшой вероятностью принесет пользу, но ничто не запрещает нам проверить были ли изменены параметры или состояние этого компонента.

Например, в случае с компонентом \textit{List} мы можем проверить, не был ли изменен список с отображаемыми элементами и вернуть соответствующее значение.

Для того, чтобы осуществить эту проверку, мы можем использовать два параметра, которые React передает в вызов этого метода: \textit{nextProps} и \textit{nextState}, которые отвечают за будущие параметры и состояние этого компонента соответственно.

В нашем случае реализацию может выглядеть следующим образом:

\begin{lstlisting}
shouldComponentUpdate(nextProps, nextState) {
  return this.state.items !== nextState.items
}
\end{lstlisting}

Мы возвращаем \textit{true} только в том случае, если список элементов для отображения не изменился, а \textit{false} в остальных случаях. Предположим, что компонент \textit{List} может быть использован внутри другого компонента, который сам по себе изменяется довольно часто, но при этом не влияет на отображение компонента \textit{List}. В этом случае с помощью метода \textit{shouldComponentUpdate} мы можем сказать React, что не нужно обновлять компонент \textit{List} и его потомков.

Реализация проверки всех параметров компонента и его состояния на наличие изменений может ввести в уныние. А поддержка сложных реализаций метода \textit{shouldComponentUpdate} будет отнимать много времени, особенно при часто меняющихся требованиях.

В этих целях React предоставляет уже готовый компонент, который осуществляет сравнение всех параметров и состояния в методе \textit{shouldComponentUpdate}.

Использовать этот компонент очень просто, для этого достаточно наследовать наши компоненты от \textit{React.PureComponent} вместо \textit{React.Component}.

Важно заметить, что данный компонент сравнивает только ссылки объектов в параметрах и состоянии, но не осуществляет глубокое сравнение, что иногда может привести к неожиданным результатам.

Данный подход хорошо работает при использовании неизменяемых структур данных, о которых мы поговорим далее. Также стоит отметить, что глубокое сравнение сложных объектов иногда может занимать больше времени чем их отрисовка. 

Поэтому использовать \textit{PureComponent} стоит только в том случае, если есть проверенный факт потери производительности и компоненты занимают слишком много времени для отрисовки.

\subsection{Функциональные компоненты}

Еще один неочевидный факт о React заключается в том, что функциональные компоненты не дают никакой выгоды в плане производительности приложения.

Легко подумать, что они должны работать быстрее, так как не создаются экземпляры классов, нет внутреннего состояние и обработчиков событий, но все это вносит вклад в улучшение производительности как минимум второго порядка. 

На данный момент во многих ситуациях функциональные компоненты работают даже хуже, так как для них нельзя реализовать функцию \textit{shouldComponentUpdate}, которая может значительно уменьшить затраты вычислительных ресурсов.

(Прим.пер. на данный момент функциональные компоненты уже начинают править балом, для них есть hook api, кеширование и, скорее всего, различные внутренние оптимизации)

\section{Распространенные решения}

Мы уже рассмотрели, как \textit{PureComponent} может помочь нам оптимизировать отрисовку React компонентов. Если направить его в правильное русло, можно значительно улучшить производительность приложения. Но еще раз напомним, что использовать этот компонент стоит, когда есть обнаруженные и измеренные проблемы производительности.

Есть некоторое множество неочевидных моментов, когда использование \textit{PureComponent} не дает нам ожидаемый результат. Чаще всего это происходит при непредвиденных нами изменениях параметров или состояния компонента. Иногда бывает довольно сложно определить, что именно привело компонент к перерисовке, или какой компонент следует оптимизировать с помощью \textit{PureComponent}.

В этой части мы рассмотрим инструменты и подходы для исправления проблем с перерисовкой компонентов. Также мы посмотрим, как можно разделить большой компонент, чтобы улучшить производительность.

\subsection{Почему ты обновился?}

Понять, должен ли компонент обновляться или нет, можно разными способами. Один из простейших, установить специальную библиотеку, которая будет предоставлять нам такую информацию автоматически.

Прежде всего, установим библиотеку \textbf{why-did-you-update}:

\begin{lstlisting}
	npm install --save-dev why-did-you-update
\end{lstlisting}

И добавим следующий кусочек кода сразу после импорта React:

\begin{lstlisting}
if (process.env.NODE_ENV !== 'production') {
  const { whyDidYouUpdate } = require('why-did-you-update')
  whyDidYouUpdate(React)
}
\end{lstlisting}

Таким образом, мы просто говорим, что если находимся в процессе разработки, то нужно импортировать эту библиотеку и применить ее к React. Не стоит пускать ее в сборку, которая уйдет к пользователям.

Теперь, если мы вернемся к примеру компонента \textit{List} из предыдущей главы и немного его поправим, то мы сможем увидеть работу этой библиотеки в действии.

Для начала нам нужно поправить метод \textit{render}:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => (
          <Item key={item} item={item} />
        ))}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting}

Мы заменим отрисовку простых элементов внутри \textit{map} на другой копонент \textit{Item}, который скоро создадим. Этому компоненту мы будем передавать элементы списка для отрисовки, а также параметр \textit{key}, чтобы React мог понять, какие из элементов уже существовали перед обновлением.

Реализуем этот компонент с помощью \textit{React.Component}:

\begin{lstlisting}
class Item extends React.Component
\end{lstlisting}

На данный момент компонент \textit{Item} будет реализовывать только метод \textit{render} для отрисовки элементов списка:

\begin{lstlisting}
render() {
  return (
    <li>{this.props.item}</li>
  )
}
\end{lstlisting}

Также поправим использование Perf, так как сейчас нас больше интересует время, потраченное на вызовы методов \textit{render}, которые не привели к обновлению DOM:

\begin{lstlisting}
componentDidUpdate() {
  Perf.stop()
  Perf.printWasted()
}
\end{lstlisting}

Отлично, теперь мы можем запустить этот компонент. На экране мы увидим то же самое, что и раньше: элементы \textbf{foo}, \textbf{bar} и кнопку \textit{+}. Самое интересное начинается в консоли после нажатия на вышеупомянутую кнопку.

Прежде всего вывод из библиотеки \textbf{whyDidYouUpdate}, которая сообщает, какие перерисовки можно было избежать:

\begin{lstlisting}
       Item.props 
         Value did not change. Avoidable re-render!         
         before Object {item: "foo"}
         after  Object {item: "foo"}
       Item.props
         Value did not change. Avoidable re-render!
         before Object {item: "bar"}
         after  Object {item: "bar"}
\end{lstlisting}

Эти данные наглядно показывают, что даже если React не перерисовывает элементы \textbf{foo} и \textbf{bar}, соответствующие им методы render все равно вызываются. Это очень полезная информация, которую часто не так легко получить.

Далее можно увидеть вывод в консоль расширения Perf, который показывает, сколько времени было затрачено на работу методов \textit{render}, но не вызвавших изменений в DOM. 

Теперь мы легко можем поправить эту проблему заменой наследования класса \textit{Item} с \textit{extends React.Component} на:

\begin{lstlisting}
class Item extends React.PureComponent
\end{lstlisting}

Если мы снова запустим приложение и нажмем кнопку \textit{+}, то убедимся, что устрашающие сообщения в консоли больше не появляются. Это означает, что компонент \textit{Item} больше не перерисовывается без изменений параметров.

Конкретно в этом случае мы можем и не получить большой выгоды в производительности, но если вы представите себе приложение, которое отрисовывает списки из сотен элементов, то там любая лишняя перерисовка всего списка может вызывать замедление работы программы.

\subsection{Создание функций внутри метода \textit{render}}

Теперь давайте попробуем добавить новые возможности в компонент \textit{List}, как если бы мы работали с реальным приложением, и посмотрим, как мы можем свести на ноль всю пользу от использования \textit{PureComponent}.

Например, мы хотим добавить обработчик нажатий на каждый элемент списка и выводить в консоль содержимое элемента в случае его срабатывания.

Это немного далековато от чего-то реально полезного для пользователя, но вы можете легко представить, что по нажатию на элемент списка происходит любое другое событие, например открытие нового окна с детальной информацией по объекту.

Для этого мы добавим пару изменение в методы \textit{render} компонентов \textit{List} и \textit{Item}.

Начнем с первого из них:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => (
          <Item
            key={item}
            item={item}
            onClick={() => console.log(item)}
          />
        ))}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting}

Теперь параметр \textit{onClick} мы передаем функцию, которая печатает содержимое элемента в консоль, компоненту \textit{Item}.

Теперь осталось только передать эту функцию в элемент \textit{<li>} внутри компонента \textit{Item}:

\begin{lstlisting}
render() {
  return (
    <li onClick={this.props.onClick}>
      {this.props.item}
    </li>
  )
}
\end{lstlisting}

Мы все еще используем \textit{PureComponent} и ожидаем, что после добавления элемента \textbf{baz}, метод \textit{render} для уже существующих элементов списка вызываться повторно не будут.

К сожалению, если мы запустим приложение, то увидим несколько новых сообщений в консоли: первое от библиотеки \textit{whyDidYouUpdate}, которая говорит, что есть потенциально лишние вызовы метода \textit{render}, так как функция \textit{onClick} всегда одна и та же:

\begin{lstlisting}
       Item.props.onClick
         Value is a function. Possibly avoidable re-render?
         before onClick() {
           return console.log(item);
         }
         after  onClick() {
           return console.log(item);
         }
       Item.props.onClick
         Value is a function. Possibly avoidable re-render?
         before onClick() {
           return console.log(item);
         }
         after  onClick() {
           return console.log(item);
         }
\end{lstlisting}

Второе от расширения Perf, которое говорит, что мы теряем время на отрисовке компонента \textit{List > Item}

Причина, по которой в компонент \textit{Item} передается каждый раз новая функция, в том, что стрелочная функция, которая создается в каждом вызове метода \textit{render} компонента \textit{List}, возвращает каждый раз новый экземпляр функции, даже если реализация этой функции не изменилась. Это очень распространенная ошибка, которую достаточно просто поправить.

К сожалению, мы не можем вынести реализацию обработчика событий за метод \textit{render}, так как для каждого из элементов списка нам нужно выводить в консоль разные данные. Так что создание обработчика внутри цикла отрисовки списка выглядит вполне логичным решением.

Но мы можем перенести логику печати внутрь самого компонента \textit{Item}, который знает о том, по какому именно компоненту было произведено нажатие.

Давайте посмотрим, как мы можем реализовать компонент \textit{Item}, который будем наследовать от \textit{PureComponent}:

\begin{lstlisting}
class Item extends React.PureComponent	
\end{lstlisting}

В конструкторе мы привяжем к экземпляру самого класса обработчик событий, который будет частью реализации класса \textit{Item}:

\begin{lstlisting}
constructor(props) {
  super(props)
  
  this.handleClick = this.handleClick.bind(this)
}
\end{lstlisting} 

Внутри функции \textit{handleClick} мы будем вызывать функции \textit{onClick}, которую получаем из параметров, и передавать в нее содержимое текущего элемента:

\begin{lstlisting}
handleClick() {
  this.props.onClick(this.props.item)
}
\end{lstlisting}

Теперь мы можем использовать в методе \textit{render} обработчик, созданный внутри класса:

\begin{lstlisting}
render() {
  return (
    <li onClick={this.handleClick}>
      {this.props.item}
    </li>
  )
}
\end{lstlisting}

Осталось только изменить метод \textit{render} класса \textit{List} так, чтобы он не создавал новые экземпляры функций при каждом вызове:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => (
          <Item
            key={item}
            item={item}
            onClick={console.log}
          />
        ))}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting}

Как вы можете увидеть, мы передаем функцию, которую хотели использовать (в данном случае \textit{console.log}) для вызова внутри каждого дочернего компонента с нужными параметрами. Но теперь мы используем одну и ту же функцию внутри класса \textit{List}, поэтому ее не нужно пересоздавать для каждого дочернего элемента в отдельности.

Если мы запустим приложение и нажмем кнопку \textit{+}, то убедимся, что теперь в консоли снова нет сообщений о лишних вызовах метода \textit{render}.

Также, если мы кликнем по какому-либо элементу в списке, то увидим соответствующее сообщение в консоли.

Как сказал \textit{Ден Абрамов}, использование стрелочных функций внутри метода \textit{render} не является проблемой само по себе, но мы должны быть осторожны и проверять, что мы не вызываем этим лишние перерисовки компонентов.
 

\subsection{Параметры константы}

Давайте продолжим расширять наш список и посмотрим, что еще может произойти при добавлении новых возможностей. 

Рассмотрим еще одну распространенную ошибку, которая снижает эффективность \textit{PureComponent}.

Предположим, что элементы нашего списка должны мочь получать через параметры список доступных для них статусов. Такую возможность можно реализовать разными способами, но сейчас остановимся на варианте, в котором мы просто укажем доступные статусы в JSX.

Изменим метод \textit{render} компонента \textit{List} следующим образом:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => (
          <Item
            key={item}
            item={item}
            onClick={console.log}
            statuses={['open', 'close']}
          />
        ))}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting}

Параметры \textit{key}, \textit{item} и \textit{onClick} мы уже разбирали ранее. Сейчас мы добавили параметр \textit{statuses}, в котором собственно передаем массив с возможными статусами для элемента.

Теперь, если мы снова запустим приложение и нажмем кнопку \textit{+}, то увидим следующее сообщение:

\begin{lstlisting}
       Item.props.statuses
         Value did not change. Avoidable re-render!
         before ["open", "close"]
         after  ["open", "close"]
       Item.props.statuses
         Value did not change. Avoidable re-render!
         before ["open", "close"]
         after  ["open", "close"]
\end{lstlisting}

Эти сообщения говорят о том, что несмотря на то, что содержимое массивов со статусами остается одним и тем же, экземпляры этих массивов создаются заново в каждом вызове метода \textit{render}.

Причина в том, что все объекты в JavaScript при создании возвращают новый экземпляр (это не относится к примитивным типам), т.е. два отдельно созданных объекта (даже с одинаковым содержимом) всегда имеют разные адреса в памяти:

\begin{lstlisting}
   [] === []
     false
\end{lstlisting}

Помимо этого в консоли можно увидеть информацию о времени, потраченном на выполнение методов \textit{render}, не вызвавших изменений в DOM.

Основное, что мы можем сделать в данной ситуации, это вынести создание этого массива в отдельную константу. Тогда она будет инициализирована единожды, а затем использована для всех элементов списка:

\begin{lstlisting}
const statuses = ['open', 'close']
...
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => (
          <Item
            key={item}
            item={item}
            onClick={console.log}
            statuses={statuses}
          />
        ))}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting}

Если мы снова запустим приложение, то увидим, что сообщения в консоли пропали, что говорит о том, что элементы снова не перерисовываются без необходимости при добавлении новых элементов.

\subsection{Рефакторинг и хороший дизайн}

В последней части данной части мы посмотрим, как можно поправить существующий компонент (или создать новый в лучшем стиле) и улучшить при этом производительность приложения.

Слабый архитектурные решения всегда приводят к проблемам. В случае с React, например, неправильный выбор места хранения состояния внутри дерева элементов может привести к тому, что компоненты будут отрисовывать больше, чем требуется.

Как мы уже говорили ранее, от того, что какой-то компонент отрисует себя лишний раз, скорее всего хуже не станет. Проблемы обычно начинаются, когда большие списки элементов начинают дружно перерисовываться по любому чиху из вне.

Компонент, который мы сейчас создадим, похож на предыдущий пример в том смысле, что это будет еще одно приложение со списком элементов. Но теперь в нем появится форма, которая позволит пользователю добавлять новые элементы.

Как всегда, мы начнем с простого примера и будет его шаг за шагом улучшать.

Мы назовем компонент \textit{Todos}, и он будет наследовать \textit{extends React.Component}:

\begin{lstlisting}
class Todos extends React.Component
\end{lstlisting}

В конструкторе мы определим начальное состояние и привяжем обработчики событий к экземпляру класса:

\begin{lstlisting}
constructor(props) {
  super(props)
  
  this.state = {
    items: ['foo', 'bar'],
    value: '',
  }

  this.handleChange = this.handleChange.bind(this)
  this.handleClick = this.handleClick.bind(this)
}
\end{lstlisting}

У состояния есть два атрибута:

\begin{itemize}
  \item \textbf{items}: Массив с парой предустановленных элементов, в который будут добавляться новые значения
  \item \textbf{value}: Поле, в которое будет сохраняться текущее состояние ввода пользователя.
\end{itemize}

Вы уже можете догадаться, как будут выглядеть обработчики событий. Создадим метод \textit{handleChange}, который будет вызываться каждый раз, когда пользователь меняет значение в поле ввода:

\begin{lstlisting}
 handleChange({ target }) {
  this.setState({
    value: target.value,
  })
}
\end{lstlisting}

Мы уже обсуждали в Главе 6, что такой обработчик событий получает объект события (event) с полем \textit{target}, где находится новое значение поля ввода. Все, что нам остается сделать, это сохранить это значение внутри состояния компонента.

И еще один обработчик \textit{handleClick}, который будет вызываться, когда пользователь нажмет кнопку добавления нового элемента в список:

\begin{lstlisting}
handleClick() {
  const items = this.state.items.slice()
  items.unshift(this.state.value)
  
  this.setState({
    items,
  })
}
\end{lstlisting}

Этот обработчик похож на тот, который у нас уже был, с той лишь разностью, что он добавляет не константную, но введенную пользователем строку.

И остается только определить метод \textit{render}:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => <li key={item}>{item}</li>)}
      </ul>
      <div>
        <input
          type="text"
          value={this.state.value}
          onChange={this.handleChange}
        />
        <button onClick={this.handleClick}>+</button>
      </div>
    </div>
  )
}
\end{lstlisting}

В данном методе мы отрисовываем список элементов из состояния компонента, сопоставляя каждому из них элемент \textit{<li>}. Далее идет поле ввода, значение которого сохраняется в состоянии по ключу \textit{value} и кнопка для добавления нового элемента.

Теперь мы можем запустить этот компонент и убедиться, что он работает, т.е. отображаются все элементы, меняется значения ввода при наборе текста и добавляются новые элементы по нажатию на кнопку.

В общем и целом этот компонент будет работать, и даже не будет значительно замедлять приложение, но только пока вы не решите добавить пару сотен элементов. В этом случае вы сможете заметить, что ввод каждого символа начинает выполняться с ощутимой задержкой. Это происходит из-за того, что React вызывает метод \textit{render} после каждого изменения состояния, т.е. после каждого ввода со стороны пользователя, и каждый раз заново отрисовывает сотни элементов.

Мы понимаем, что после каждого введенного символа обновляться в DOM должно только это поле ввода. Но чтобы это понял React, ему приходится вызвать метод \textit{render} у всех дочерних элементов и сравнить полученный результат с предыдущим состоянием дерева элементов.

Теперь, если мы посмотрим на состояние компонента, то можем подумать о том, что хранить в одном месте и состояние поля ввода и список элементов было не лучшей идеей.

В общем случае стоит стремиться к тому, что каждый компонент должен выполнять одну, а в идеале только одну, функцию.

Основное решение в данной ситуации -- разделить компонент на два, каждый со своей частью состояния и, соответственно, зоной ответственности.

Для того, чтобы сделать это, нам потребуется общий родительский компонент для новых компонентов, так компоненты все таки связаны. Мы не хотим перерисовывать весь список элементов после каждого ввода пользователя, но мы точно хотим обновить список после добавления нового элемента в список элементов.

Сначала мы поправим компонент \textit{Todos}, чтобы он хранил только список элементов. 

Затем мы создадим отдельные компоненты для отрисовки списка элементов и отображения формы для ввода пользователя.

Начнем с компонента \textit{Todos}:

\begin{lstlisting}
class Todos extends React.Component
\end{lstlisting}

Теперь в состоянии мы оставим только один атрибут \textit{items}, где будет тот же самый список элементов. Также в этом компоненте останется только один обработчик событий, который будет добавлять новые элементы в состояние:

\begin{lstlisting}
constructor(props) {
  super(props)
  
  this.state = {
    items: ['foo', 'bar'],
  }
  
  this.handleSubmit = this.handleSubmit.bind(this)
}
\end{lstlisting}

Реализация обработчика событий значительно не меняется:

\begin{lstlisting}
 render() {
  return (
    <div>
      <List items={this.state.items} />
      <Form onSubmit={this.handleSubmit} />
    </div>
  )
}
\end{lstlisting}

Компонент \textit{List} будет получать список элементов для отрисовки через параметры. Компонент \textit{Form} в свою очередь будет получать через параметры функцию для добавления новых элементов.

Теперь мы можем создать дочерние компоненты \textit{List} и \textit{Form}. Первый из них мы можем собрать из кода предыдущей версии компонента \textit{Todos}.

Также, чтобы компонент \textit{List} перерисовывался только при изменении получаемого списка, мы будем наследовать его от компонента \textit{PureComponent}:

\begin{lstlisting}
class List extends React.PureComponent
\end{lstlisting}

В методе \textit{render} мы будем просто отрисовывать список элементов:

\begin{lstlisting}
render() {
  return (
    <ul>
      {this.props.items.map(item => <li key={item}>{item}</li>)}
    </ul>
  )
}
\end{lstlisting}

Теперь создадим компонент \textit{Form}, в котором нам нужно будет сохранять состояние ввода пользователя, а также обрабатывать добавление новых элементов через получаемую в параметрах функцию. Этот компонент мы также будет наследовать от \textit{PureComponent}:

\begin{lstlisting}
class Form extends React.PureComponent
\end{lstlisting}

В конструкторе мы определим начальное значение поля ввода и привяжем обработчик ввода к экземпляру класса:

\begin{lstlisting}
constructor(props) {
  super(props)
  
  this.state = {
    value: '',
  }
  
  this.handleChange = this.handleChange.bind(this)
}
\end{lstlisting}

Реализация обработчика остается неизменной относительно аналогичного из компонента \textit{Todos} до начала разделения на более мелкие компоненты:

\begin{lstlisting}
handleChange({ target }) {
  this.setState({
    value: target.value,
  })
}
\end{lstlisting}

И в методе \textit{render} нам остается только отрисовать форму ввода и кнопку для сохранения элементов:

\begin{lstlisting}
render() {
  return (
    <div>
      <input
        type="text"
        value={this.state.value}
        onChange={this.handleChange}
      />
      <button
        onClick={() => this.props.onSubmit(this.state.value)}
      >+</button>
    </div>
  )
}
\end{lstlisting}

Таким образом мы получили поле ввода с кнопкой. Стоит также заметить, что мы создаем стрелочную функцию прямо в методе \textit{render}, но здесь мы можем спокойно это делать, так как нет дочерних элементов, которых это будет заставлять лишний раз перерисовываться (наследников компонента \textit{PureComponent} или компонентов с похожими возможностями).

Готово. Теперь, если вы запустите приложение, то увидите, что визуально оно не изменилось, но изменения в поле ввода не заставляются перерисовываться весь список, что значительно увеличивает производительность даже на больших списках.

Мы решили проблему перерисовки конкретного списка в конкретном приложении. Отрисовка списков очень часто является узким горлышком в производительности приложений с пользовательским интерфейсом в целом и React приложений в частности, поэтому всегда проверяйте, что заставляет перерисовываться списки в ваших приложениях.

\section{Инструменты и библиотеки}

В этой части мы рассмотрим несколько полезных инструментов и библиотек, которые можно добавить в проект, чтобы эффективнее отслеживать и решать проблемы с производительностью.

\subsection{Неизменяемые объекты}

Как мы уже видели, один из самых мощных инструментов оптимизации заключается в использовании метода \textit{shouldComponentUpdate} или компонента \textit{PureComponent}.

Единственная проблема в том, что \textit{PureComponent} использует поверхностное \textit{shallow} сравнение, т.е. только ссылки на объекты. Поэтому если мы изменим какое-либо поле объекта, передаваемого такому объекту через параметры, не создавая при этом новый объект, то компонент решит, что никаких изменений не было и перерисовываться не будет.

В общем случае, поверхностное сравнение не может распознать изменение отдельных полей внутри объекта, что может приводить к отображению устаревшей информации в DOM дереве.

Один из способов решения этой проблемы -- использование \textbf{неизменяемых данных (immutable data)}, т.е. таких данных, которые после своего создания не могут быть изменены.

Например, мы можем обновить состояние компонента следующим образом:

\begin{lstlisting}
const obj = this.state.obj
obj.foo = 'bar'
this.setState({ obj })
\end{lstlisting}

Несмотря на то, что поле \textit{foo} объекта меняется, сам объект (в смысле ссылка на него) остается тем же. Если такой код отработает внутри компонента, который наследуется от \textit{PureComponent}, то перерисовки не произойдет.

Вместо этого мы можем создавать новый экземпляр объекта при каждом обновлении состояния:

\begin{lstlisting}
const obj = Object.assign({}, this.state.obj, 
  { foo: 'bar' })

this.setState({ obj })
\end{lstlisting}

В этом случае мы получаем новый объект, в который копируются все поля из \textit{this.state.obj}, а также в поле \textit{foo} устанавливается значение \textit{bar}. Так как создается новый объект, ссылка на него будет отличаться от исходного, а поверхностное сравнение сможет обнаружить изменения.

С помощью ES2015 и Babel можно реализовать ту же идею через spread оператор: 

\begin{lstlisting}
const obj = { ...this.state.obj, foo: 'bar' }
this.setState({ obj })
\end{lstlisting}

Такой вариант записи лаконичнее и реализует аналогичную функциональность, но требует дополнительных инструментов, чтобы быть запущенным в браузере. 

Также есть библиотека \textit{immutable.js}, которая предоставляет вспомогательные функции для упрощения работы с неизменяемыми объектами, но ее использование требует небольшого изучения API этой библиотеки.

\subsection{Инструменты мониторинга}

Мы уже рассматривали, как мы можем использовать \textit{Perf} для отслеживания производительности приложения.

В нашем примере мы использовали методы жизненного цикла компонента для запуска и остановки записи подсчета производительности приложения:

\begin{lstlisting}
componentWillUpdate() {
  Perf.start()
}

componentDidUpdate() {
  Perf.stop()
  Perf.printOperations()
}
\end{lstlisting}

После вызова метода \textit{stop} мы вызываем метод \textit{printOperations}, чтобы распечатать в консоль браузера, какие операции в DOM выполнил React для применения всех необходимых изменений.

Этот инструмент очень удобен, но нам приходится использовать методы жизненного цикла и загрязнять кодовую базу для измерения производительности.

Лучшим вариантом для нас было бы иметь возможность измерять производительность компонентов, не модифицирую при этом сами компоненты. И такую возможность предоставляет для нас расширение \textit{chrome-react-perf} для Chrome.

Его можно установить, перейдя в браузере по следующей \href{https://chrome.google.com/webstore/detail/reactperf/hacmcodfllhbnekmghgdlplbdnahmhmm}{ссылке}.

Данное расширение добавляет новую вкладку в DevTools, с помощью которой мы можем запускать и останавливать \textit{Perf} без необходимости вносить изменения в код приложения.

Еще один инструмент, который помогает нам облегчить сбор информации о производительности приложения, -- \textit{react-perf-tool}. Данный инструмент представляет собой компонент, который мы можем добавить в наше приложение, для того, чтобы получить удобный интерфейс работы с \textit{Perf} прямо внутри окна браузера.

Данный компонент отрисовывает небольшую консоль внизу страницы, с которой мы можем запускать и останавливать сбор информации о производительности. Помимо этого \textit{react-perf-tool} печатает данные не в виде таблицы, а в виде графа, на котором наглядно видно,  какие компоненты расходуют больше вычислительной мощности в сравнении с остальными. 

\subsection{Плагины Babel}

Список плагинов Babel открывает \textbf{React constant elements transformer (прим.пер. на всякий случай я не буду называть его как Неизменяемых элементов React преобразователь)}. Данный плагин ищет в коде все элементы, отрисовка которых не зависит от передаваемых им параметров и выносит их из методов render (или функциональных компонентов), чтобы уменьшить количество вызовов функции \textit{createElement}.

Для того, чтобы начать им пользоваться, прежде всего необходимо его установить:

\begin{lstlisting}
	npm install --save-dev babel-plugin-transform-react-constant-elements
\end{lstlisting}

А затем нам необходимо добавить его в файл конфигурации Babel \textit{.babelrc}:

\begin{lstlisting}
{
  "plugins": ["transform-react-constant-elements"]
}
\end{lstlisting}

Еще один плагин, который вы потенциально можете захотеть поставить, -- \textbf{React inline elements transform}. Он заменяет все объявления JSX (или вызовы \textit{createElement}) на более производительные аналоги.

Для установки плагину необходимо выполнить:

\begin{lstlisting}
npm install --save-dev babel-plugin-transform-react-inline-elements
\end{lstlisting}

А затем также добавить в файл конфигурации Babel:

\begin{lstlisting}
{
  "plugins": ["transform-react-inline-elements"]
}
\end{lstlisting}

Оба плагина должны использоваться только в финальный сборке, так как изменения, которые они применяют к коду, могут значительно усложнить отладку приложения.

\section{Заключение}

На этом наш экскурс в вопросы производительности React приложений подходи к концу, и теперь мы можем оптимизировать наши продукты так, чтобы они оставляли лучшее впечатление у пользователей.

В этой главе мы разобрались в процессе согласования и как React ищет минимальное количество операций в DOM для применения всех изменений. А также мы посмотрели, как мы можем ему в этом помочь при помощи использования ключей.

Также всегда используйте финальную (production) сборку приложения для измерения производительности при помощи \textit{Perf}. Это поможет вам точнее определить, какие части приложения необходимо оптимизировать.

После того, как вы нашли узкое горлышко, вы можете применить один из способов исправления проблем с производительностью, рассмотренных в этой главе. Например, вы можете использовать компонент \textit{PureComponent} и неизменяемы объекты для сокращения количества вызовов методов \textit{render}.

Избегайте распространенных ошибок, связанных с использованием \textit{PureCompoentn}, так как создание обработчиков событий внутри метода \textit{render} или использования константных объектов.

Мы также немного переосмыслили подход к проектированию компонентов так, чтобы они показывали большую производительность. Но в общем и целом, как всегда, нужно стремиться сохранять компоненты небольшими и выполняющими одну, каждый свою, конкретную задачу.

И в конце мы поговорили о неизменяемых объектах и увидели, почему важно не вносить изменения в существующие объекты, чтобы не потерять пользу от использования методов \textit{shouldComponentUpdate} и \textit{shallowCompare}. И в конце мы посмотрели на несколько интересных инструментов, которые могу помочь вам с улучшением производительности приложений.

В следующий главе мы встретимся лицом к лицу с тестированием и отладкой. 

