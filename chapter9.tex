\chapter{Улучшаем Производительность Приложений}

Производительность web приложения может в значительной степени влиять на пользовательский опыт и конверсию. React реализует множество подходов, чтобы уменьшить изменение DOM браузера настолько, насколько это возможно. Применение изменений к DOM - достаточно дорогостоящая операция, поэтому критически важным становится уменьшение их количества.

Однако, есть некоторое множество сценариев, в которых React не может оптимизировать процесс отрисовки компонентов. В таких случаях разработчик вынужден реализовать решение, которое поможет приложению работать плавно.

В этой главе мы разберем базовые концепции производительности React приложений, и посмотрим на API библиотеки React, которые мы можем использовать, чтобы помочь библиотеке оптимально обновлять DOM. Также мы разберем распространенные ошибки, которые приводят к существенному ухудшению производительности приложения.

На простых примерах мы разберем, какие инструменты мы можем добавить в проект, чтобы отслеживать производительность приложения и искать проблемные участки кода. Также мы посмотрим, как неизменяемые (immutable) объекты и \textit{PureComponent} могут помочь в создании быстрого приложения.

В этой главе мы разберем следующие вопросы:

\begin{itemize}
	\item Как работает согласование (reconciliation), и как мы можем использовать ключи (keys) для увеличения эффективности этого процесса
	\item Как использование production версии React меняет его производительность
	\item Как использовать \textit{PureComponent} и метод жизненного цикла \textit{shouldComponentUpdate}
	\item Основные способы оптимизации приложения и ошибки, вызывающие падение производительности
	\item Использование неизменяемых (immutable) данных
	\item Полезные инструменты и библиотеки для улучшения производительности приложения
\end{itemize}

\section{Согласование и ключи}

В большинстве случаев React работает достаточно быстро, чтобы не думать о проблемах производительности приложения. React использует различные техники для оптимизации отрисовки компонентов на экране.

Для отрисовки React вызывает рекурсивно метод \textbf{render} у компонента, затем у его потомков, затем у потомков потомков и т.д. Вызов метода \textit{render} возвращает дерево элементов, которое React использует для осознания, что нужно изменить в DOM для обновления UI.

Когда состояние компонента меняется, React снова пересоздает дерево элементов с помощью метода \textit{render}, а затем сравнивает полученный результат с предыдущим деревом. React достаточно умен, чтобы понять, какие операции достаточно применить к DOM, чтобы отобразить ожидаемые изменения UI. Этот процесс называется \textbf{согласованием (reconciliation)} и работает под капотом React. Благодаря этому, мы можем описывать в декларативном стиле, как должны выглядеть наши компоненты, пока React делает всю остальную работу по отрисовке.

React пытается делать как можно меньше изменений в DOM, так как внесение изменений в DOM - относительно дорогостоящая операцию.

Однако, сравнение двух деревьев с элементами также не бесплатно, поэтому React делает два допущения, чтобы упростить этот процесс:

\begin{itemize}
	\item Если два элемента обладают разным типом, они отображаются в разные деревья
	\item Разработчик может использовать ключи (keys) для обозначения дочерних элементов стабильными при разных вызовах метода \textit{render}
\end{itemize}  

С точки зрения разработчика второй пункт интереснее, так как предоставляет инструмент для помощи React с оптимизацией отрисовки компонентов.

Сейчас мы посмотрим на простой пример, чтобы понять, как использование ключей может значительно повлиять на производительность приложения.

Давайте создадим простой компонент, который будет отрисовывать список объектов и кнопку, по нажатию на которую будет добавляться еще один объект в список, что будет приводить к перерисовке компонента.

Мы создадим компонент с помощью класса, так как нам нужно хранить список объектов для отрисовки, а также создадим обработчик событий для кнопки:

\begin{lstlisting}
class List extends React.Component
\end{lstlisting}

В конструкторе класса \textit{List} добавим создание списка объектов для первой отрисовки, а также привяжем обработчик событий к экземпляру класса:

\begin{lstlisting}
constructor(props) {
  super(props)
  this.state = {
    items: ['foo', 'bar'],
  }

  this.handleClick = this.handleClick.bind(this)
}
\end{lstlisting}

Создадим собственно сам обработчик событий, который будет добавлять новый элемент в список объектов на отрисовку:

\begin{lstlisting}
handleClick() {
  this.setState({
    items: this.state.items.concat('baz'),
  })
}
\end{lstlisting}

И в конце создадим метод \textit{render}, который будет отрисовывать объекты, сохраненные внутри компонента, а также кнопку для добавления новых:

\begin{lstlisting}
render() {
  return (
    <div>
      <ul>
        {this.state.items.map(item => <li>{item}</li>)}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}	
\end{lstlisting}

Компонент готов, и если вы добавите его в свое приложение (или создадите для этого новое с помощью \textit{create-react-app}), то вы увидите на экране элементы \textbf{foo} и \textbf{bar}, а также кнопку \textit{+}, по нажатию на которую добавиться элемент \textbf{baz}. 

Все работает так, как мы и ожидаем, но для получения полноты картины происходящего внутри React, мы добавим еще один инструмент, который поможет собирать и отображать информацию о производительности приложения. Для его установки можно воспользоваться npm:

\begin{lstlisting}
	npm install --save-dev react-addons-perf
\end{lstlisting}

После установки мы можем импортировать его в файл с компонентом $List$:

\begin{lstlisting}
import Perf from 'react-addons-perf
\end{lstlisting}

У объекта $Perf$ есть несколько полезных методов, которые мы можем использовать для отслеживания производительности React компонентов. С помощью методов $start()$ и $stop()$ мы можем соответственно начать и остановить запись информации о производительности компонента. 

Есть несколько методов для отображения в консоли информации, собранной ранее. Один из самых используемых - $printWasted$, который печатает информацию о том, сколько времени было затрачено на вызовы метода $render$, которые не привели к изменению DOM. Также есть метод $Perf$, который позволяет получать информацию о том, какие операции в DOM выполняет React. Этот метод называет $printOperations$, и мы будем использовать его для оценки влияния использования Ключей на производительность приложения. 

Для того, чтобы начинать и останавливать сбор информации о производительности, мы можем методы жизненного цикла $componentWillUpdate$ и $componentDidUpdate$ соответственно, в последнем мы можем также печатать результаты.

Сначала реализуем метод $componentWillUpdate$, который вызывается непосредственно перед обновлением и перерисовкой компонента:

\begin{lstlisting}
componentWillUpdate() {
  Perf.start()
}
\end{lstlisting}

Как и было сказано выше, в этом методе нужно просто начать сбор информации о производительности с помощью метода $start()$. После того, как компонент обновился, мы можем остановить сбор информации и распечатать результаты:

\begin{lstlisting}
componentDidUpdate() {
  Perf.stop()
  Perf.printOperations()
}
\end{lstlisting}

Как вы видите, мы останавливаем измерения и вызываем метод \textit{printOperations}, чтобы увидеть, какие операции сделал React над DOM для добавления элемента \textbf{baz} на экран.

Если мы запустим компонент и нажмем кнопку \textit{+}, то увидим в консоли браузера список совершенных операций в виде таблицы. Нас интересуют столбцы \textit{Operation}, который показывает \textit{"insert child"}, и \textit{Payload}, в котором мы можем увидеть \textit{"\{"toIndex":2,"content":"LI"\}"} 

React распознал, что после добавления новой строки в список необходимо создать новый дочерний элемент \textit{Li}, причем индекс этого элемента должен быть 2 (т.е. третий элемент).

Как вы можете заметить, вместо того, чтобы перерисовывать все компоненты, React высчитал минимально количество операций, которых будет достаточно для обновления DOM. Этот механизм работает прекрасно, и его достаточно для большинства ситуаций, которые могут возникнуть.

Однако есть случаи, когда у React оказывается немного недостаточно мозгов для выбора оптимального набора операций. В некотором множестве таких случаем на помощь может придти использование Ключей. Если мы немного поправим пример выше и сделаем добавление \textbf{baz} не в конец списка, а в начало, то мы увидим совсем другую картину. 

Для того, чтобы добавить \textbf{baz} в начало списка, мы можем использовать метод \textit{unshift}, но его проблема в том, что он не создает новый массив, а мутирует существующей. Для того, чтобы создать копию массива, мы можем использовать метод \textit{slice} без аргументов (прим.пер. или использовать спред оператор, привет из 2019):

\begin{lstlisting}
handleClick() {
  const items = this.state.items.slice()
  
  items.unshift('baz')
  this.setState({
    items,
  })
}
\end{lstlisting}

Таким образом мы копируем массив, добавляем в его начало строку \textbf{baz} и сохраняем обратно в state, вызывая тем самым перерисовку.

Теперь, когда мы запустим компонент снова, то снова увидим элементы \textbf{foo} и \textbf{bar}, но после нажатия на кнопку \textit{+}, строка \textbf{baz} будет добавлена уже в начало списка.

Все работает так, как мы ожидаем, но если мы снова откроем DevTools, то увидим, что на этот раз React совершил множество операций над DOM, а именно:

\begin{itemize}
  \item Заменил текст первого элемента на \textbf{baz}
  \item Заменил текст первого элемента на \textbf{foo}
  \item Добавил в конец списка новый элемент с текстом \textbf{bar} и индексом 2
\end{itemize}

Таким образом React вместо того, чтобы добавить один новый дочерний элемент в начало списка, изменил оба существующих и добавил новый элемент в конец.

Это происходит из-за того, что React после сравнения первых элементов до и после перерисовки увидел в них разницу и поправил DOM в соответсвии с этими изменениями, затем то же самое произошло со вторыми элементами, а в конце React увидел, что в списке появился новый элемент и добавил соответствующий ему элемент.

Конкретно в этом примере это не приводит к видимым потерям производительности, но в реальном приложении могут отображаться списки из сотен элементов, полная перерисовка которых может привести к существенному замедлению приложения.

Но каждая проблемы имеет свое решение, и в данном случае мы можем собственно использовать \textbf{Ключи}, которые помогут React понимать, какие из элементов обновились, добавились или удалились.

Для использования ключей достаточно добавить уникальный атрибут \textit{key} каждому из элементов списка. Важно, чтобы эти ключи не менялись для каждого элемента после перерисовки, так как React будет использовать их для сопоставления элементов до и после перерисовки.

Например, мы можем изменить метод \textit{render} следующим образом:

\begin{lstlisting}
render() {
  return (
    <div> 
      <ul>
        {this.state.items.map(item => <li key={item}>{item}</li>)}
      </ul>
      <button onClick={this.handleClick}>+</button>
    </div>
  )
}
\end{lstlisting} 

После того как мы установили значение поля \textit{key} для каждого из элементов в значение этих элементов, мы можем запустить приложение заново. Сразу же мы можем отметить, что функционально поведение компонента не изменилось: есть список из двух элемента и кнопка, по нажатию на которую добавляется новый элемент в начало списка.

Однако, если мы откроем DevTool, то увидим, что теперь снова всего одна операция над DOM, причем это операция добавления дочернего элемента по индексу 0.

Таким образом мы помогли React правильно рассчитать минимальное количество операций, которых будет достаточно для обновления DOM. С помощью этого простого метода мы можем избежать значительных падений производительности при отображении больших списков элементов.

Также отметим, что если мы забудем добавить ключи там, где это требуется, React вежливо напомнит нам об этом:

\begin{quotation}
	\textbf{Each child in an array or iterator should have a unique "key" prop. Check the render method of `List`.}
\end{quotation}

Это сообщение очень удобно, так как говорит о том, какой именно компонент нам необходимо поправить.

Также, если вы используете \textbf{Eslint}, о котором мы говорили в Главе 2, и добавили правило \textit{jsx-key} для \textit{eslint-plugin-react}, то получите аналогичную ошибку на этапе статического анализа кода.


\section{Техники оптимизации}

Важно заметить, что во всех примерах в этой книге мы используем или приложение, созданное с помощью \textit{create-react-app}, или приложение, созданное с нуля, но всегда с версией React для разработки (development version). 

Использование версии React для разработки очень удобно для написания кода и отладки, но нужно понимать, что все проверки и уведомления стоят потерь производительности приложения, которых хотелось бы избежать в финальной сборке приложения.  

Таким образом, первая оптимизация, которую мы должны сделать, это собрать приложение при установленной переменной окружения NODE\_ENV в \textit{production}. 
В случае использования \textbf{Webpack} это всего лишь вопрос использования \textit{DefinePlugin}:


\begin{lstlisting}
new webpack.DefinePlugin({
  'process.env': {
    NODE_ENV: JSON.stringify('production')
  }
}),
\end{lstlisting}

Дальнейшим улучшением нашей сборки может быть минимизация кода, после которой бандл приложения будет меньше весить, а значит быстрее загружаться по сети. Для этого мы можем добавить соответствующий плагин в список плагинов \textbf{Webpack}:

\begin{lstlisting}
new webpack.optimize.UglifyJsPlugin()
\end{lstlisting}

Если мы запустим приложение и поймем, что некоторые его части все еще выполняются медленно, то мы можем начать применять другие методы оптимизации React приложения.

Важно сказать, что не стоит оптимизировать приложение, пока нет измерений его производительности и понимания, что является узким горлышком. Преждевременная оптимизация приложений как правило ведет к излишней сложности последних, чего мы конечно хотели бы избежать. 

Помимо этого, в очередной раз напомним, что React, независимо от нашего кода, уже применяет различные методы оптимизации, так что в большинстве случаев нам вообще не стоит об этом задумываться.

Однако в некоторых случаях, когда из коробки React работает недостаточно быстро, и мы хотим ему помочь, мы можем приказать React остановить процесс согласования для частей дерева элементов.

\subsection{shouldComponentUpdate}

Первое знакомство с процессом согласования в React может стать некоторой болью для многих разработчиков. Интуитивно мы ожидаем, что если с компонентами ничего не происходит, то метод \textit{render} для них не вызывается повторно. К сожалению это далеко от истины.

На самом деле, для того, чтобы правильно оценить все изменения, которые необходимо выполнить в DOM, React вызывает метод \textit{render} для все компонентов, а затем сравнивает результат с предыдущим состоянием дерева элементов.

Если ничего не изменилось, то никаких изменений не будет применено к DOM, но если компоненты сами по себе выполняют тяжелые (с точки зрения вычислений) операции, то они могут замедлять работу всего приложения, даже если изменений в DOM при этом совершаться не будет.

React не может сам оценить, какие компоненты стоит обновлять, а какие нет, но мы можем реализовать специальный метод, чтобы помочь ему в этом вопросе.

Этот метод называется \textit{shouldComponentUpdate}, и если он вернет \textit{false} в процессе обновления дерева, то для него и всех его дочерних элеметов метод \textit{render} вызван не будет.


Например, если вы просто добавите следующий код в созданный ранее \textit{List}:

\begin{lstlisting}
shouldComponentUpdate() {
  return false
}
\end{lstlisting}

То при нажатии на кнопку \textit{+} вы не увидите никаких изменений, несмотря на то, что состояние приложения меняется. Это происходит из-за того, что мы явно сказали React, что обновлять компонент не нужно.

Просто возвращать из этого метода \textit{false} с небольшой вероятностью принесет пользу, но ничто не запрещает нам проверить не были ли изменены параметры или состояние этого компонента.

Например, в случае с компонентом \textit{List} мы можем проверить, не был ли изменен список с отображаемыми элементами и вернуть соответствующее значение.

Для того, чтобы осуществить эту проверку, мы можем использовать два параметра, которые React передает в вызов этого метода: \textit{nextProps} и \textit{nextState}, которые отвечают за будущие параметры и состояние этого компонента соответственно.

В нашем случае реализацию может выглядеть следующим образом:

\begin{lstlisting}
shouldComponentUpdate(nextProps, nextState) {
  return this.state.items !== nextState.items
}
\end{lstlisting}

Мы возвращаем \textit{true} только в том случае, если список элементов для отображения не изменился, а \textit{false} в остальных случаях. Предположим, что компонент \textit{List} может быть использован внутри другого компонента, который сам по себе изменяется довольно часто, но при этом не влияет на отображение компонента \textit{List}. В этом случае с помощью метода \textit{shouldComponentUpdate} мы можем сказать React, что не нужно обновлять компонент \textit{List} и его потомков.

Реализация проверки всех параметров компонента и его состояния на наличие изменений может ввести в уныние. А поддержка сложных реализаций метода \textit{shouldComponentUpdate} будет отнимать много времени, особенно при часто меняющихся требованиях.

В этих целях React предоставляет уже готовый компонент, который осуществляет сравнение всех параметров и состояния в методе \textit{shouldComponentUpdate}.



\subsection{Stateless functional components}

\section{Common solutions}

\subsection{Why did you update?}

\subsection{Creating functions inside the render method}

\subsection{Constants props}

\subsection{Refactoring and good design}

\section{Tools and libraries}

\subsection{Immutability}

\subsection{Monitoring tools}

\subsection{Babel plugins}

\section{Заключение}
















